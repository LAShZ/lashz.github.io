[{"content":"LeetCode刷题笔记\u0026ndash;剑指Offer 07 题目：重建二叉树 题目链接。\n输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n 示例\n 输入：\n前序遍历 preorder = [3,9,20,15,7]\n中序遍历 inorder = [9,3,15,20,7]\n输出：\n 3 / \\ 9 20 / \\ 15 7 限制:\n0 \u0026lt;= 节点个数 \u0026lt;= 5000\n题解 本题难度不高，主要是对于二叉树的遍历方式的掌握。\n前序遍历是先遍历根节点，然后遍历左子树，最后遍历右子树。\n中序遍历是先遍历左子树，然后遍历根节点，最后遍历右子树。\n后续遍历是先遍历左子树，然后遍历右子树，最后遍历根节点。\n所以，可以通过前序遍历，找到二叉树的根节点，再通过找到的根节点，在中序遍历序列中，将树在根节点的前后划分为左子树和右子树，最后对子树进行递归或是迭代，直到将所有节点都插入树内。\n以给出的示例为例，首先通过前序遍历序列的第一个值preorder[0] = 3知道根节点为3，然后在中序遍历序列中找到值为3的节点inorder[1]，这样就知道了左子树的节点为[9]，右子树的节点为[15,20,7]。因为preorder[0]为根节点，且由中序遍历可知，左子树加上根节点的节点数序号为index = 1（从0开始计数），所以左子树的节点为preorder[1: index+1]或是inorder[:index]，右子树的节点为preorder[index+1: ]或是inorder[index+1:]。\n下面给出递归和迭代两种方法的代码。\n递归法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } root := \u0026amp;TreeNode{Val:preorder[0]}\t// 建树  var index int for i := range inorder{ if inorder[i]==preorder[0]{\t// 找到根节点  index = i break } } root.Left = buildTree(preorder[1:index+1],inorder[:index])\t// 左子树递归  root.Right = buildTree(preorder[index+1:],inorder[index+1:])\t// 右子树递归  return root } 递归法使用的是DFS，用示例的输入演示整个递归的过程如下图所示，数字代表插入子树的顺序：\n迭代法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } var stack []*TreeNode\t//储存节点的栈 \troot := \u0026amp;TreeNode{Val: preorder[0]} cur := root for pre, in := 1, 0; pre \u0026lt; len(preorder); pre++ { if cur.Val != inorder[in] {\t// 当前节点不是叶子节点 \tstack = append(stack, cur)\t// 节点入栈 \tcur.Left = \u0026amp;TreeNode{Val: preorder[pre]}\t// 插入左子树 \tcur = cur.Left\t// 向下层移动 \t} else {\t// 已经碰到了叶子节点 \tin++\t// 将该叶子节点从给出的序列中删除 \tfor len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1].Val == inorder[in] {\t// 退回到上一个有叶子节点的根节点 \tin++ cur = stack[len(stack)-1] stack = stack[:len(stack)-1] } cur.Right = \u0026amp;TreeNode{Val: preorder[pre]}\t// 插入右子树 \tcur = cur.Right } } return root } 迭代法出现在字节跳动面试题中。使用的方法是DFS，一路向下将节点插入树内，直到找到叶子节点，然后退回至有右叶子的第一个根节点，再对右子树DFS。用示例的输入演示整个迭代的过程如下图所示，数字代表插入节点的顺序：\n","date":"2021-01-05T19:50:31+08:00","permalink":"https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-07/","title":"LeetCode 剑指Offer 07"},{"content":"LeetCode刷题笔记\u0026ndash;剑指Offer 06 题目：从尾到头打印链表 题目链接。\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n 示例\n 输入：\nhead = [1, 3, 2]\n输出：\n[2, 3, 1]\n限制:\n0 \u0026lt;= 链表长度 \u0026lt;= 10000\n题解 本题最容易想到的就是使用一个栈，利用栈先进后出的特性将链表内的值都放入，然后再从栈中取出放入数组内，即可实现倒序输出。不过由于Go语言并无现成的栈的数据结构，且要自己实现显得整到题目的代码较为臃肿，故可以使用别的方法。下面给出我的两种思路（其实归根结底还是用的栈）\n利用defer和匿名函数 虽然Go语言中并无现成的栈的数据结构，但是Go语言的defer的执行顺序为先进后出（关于defer的介绍可以参考博主的这篇博客，关于匿名函数和闭包的介绍可以参考博主的这篇博客），因此我们可以利用这个特性，循环到链表的每一个节点时，都通过defer调用一个匿名函数，匿名函数的功能为将该节点的值加到数组尾部。当函数执行到return语句时，就按照倒序将链表的值放入了数组中。需要注意的一点是，使用这种方式时，函数的返回值必须命名，否则执行完return语句后函数将返回一个空值，而不会把所有defer执行完成后的数组返回。下面给出代码：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) (list []int) { for ; head != nil; head = head.Next { temp := head.Val defer func() { list = append(list, temp) }() } return } 执行用时: 4 ms\n内存消耗: 4.1 MB\n可以看到这种方法虽然简便，且利用了Go的特性，但是用时和内存消耗都较大，比较不理想。下面给出第二种更好的方法\n两次遍历 先通过一次遍历整个链表，得到整个链表的长度，然后使用make初始化一个与链表长度相等的数组，再通过第二次遍历整个链表，将链表中的元素按从数组尾部到头部的顺序填充入数组内。下面给出代码：\n/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) []int { var length int temp := head for ;temp != nil; length++ { temp = temp.Next } list := make([]int, length) for ;head != nil; length-- { list[length - 1] = head.Val head = head.Next } return list } 执行用时: 0 ms\n内存消耗: 2.8 MB\n这种方法的执行用时和内存消耗均击败了100%的用户。\n","date":"2021-01-05T11:24:07+08:00","permalink":"https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-06/","title":"LeetCode 剑指Offer 06"},{"content":"LeetCode刷题笔记\u0026ndash;剑指Offer 05 题目：把数字翻译成字符串 题目链接。\n请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n 示例\n 输入：\ns = \u0026ldquo;We are happy.\u0026rdquo;\n输出：\n\u0026ldquo;We%20are%20happy.\u0026rdquo;\n限制:\n0 \u0026lt;= s 的长度 \u0026lt;= 10000\n题解 直接使用strings下的Replaces接口函数即可。\n函数声明为: func Replace(s, old, new string, n int) string\n功能为: 返回将s中前n个不重叠old子串都替换为new的新字符串，如果n\u0026lt;0会替换所有old子串。\n代码：\nfunc replaceSpace(s string) string { return strings.Replace(s, \u0026#34; \u0026#34;, \u0026#34;%20\u0026#34;, -1) } 执行用时: 0 ms\n内存消耗: 1.9 MB\n","date":"2021-01-04T21:54:24+08:00","permalink":"https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-05/","title":"LeetCode 剑指Offer 05"},{"content":"LeetCode刷题笔记\u0026ndash;剑指Offer 04 题目：二维数组中的查找 题目链接。\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n 示例\n 现有矩阵 matrix 如下：\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n限制：\n0 \u0026lt;= n \u0026lt;= 1000\n0 \u0026lt;= m \u0026lt;= 1000\n题解 这道题最简单的做法就是遍历整个数组，每一个元素都拿来比较，找到了就返回true，遍历完之后还没找到就返回false，但这种方法的时间复杂度为O(NM)，且并未利用数组内元素递增的特点。\n对于这道题我们先将数组画出来，可以发现对于任意一个元素，总是要大于它的左下方的元素。\n所以，我们可以先在第一行进行搜索，找到第一个大于目标值的数，然后一直朝着左下方搜索，该处的值大于目标值就朝左，小于目标值就朝右。整个搜索过程中，找到对应值就返回true，超出边界就立即停止搜索，并返回false。在上图中搜索14的过程如下图所示：\n程序代码如下：\nfunc findNumberIn2DArray(matrix [][]int, target int) bool { i := 0 if (len(matrix) == 0 || len(matrix[0]) == 0) {\t// 为空数组直接返回false  return false } for ; ((i \u0026lt; len(matrix[0]) - 1) \u0026amp;\u0026amp; matrix[0][i] \u0026lt; target); i++ {\t// 在第一行大于target的或是超出边界 \t} for j := 0; ; { if i \u0026lt; 0 || j \u0026gt; (len(matrix)-1) { return false } if matrix[j][i] == target { return true } else if matrix[j][i] \u0026gt; target {\t// 朝左  i-- } else {\t// 朝下  j++ } } } 执行用时: 24 ms\n内存消耗: 6.6 MB\n","date":"2021-01-04T19:39:31+08:00","permalink":"https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/","title":"LeetCode 剑指Offer 04"},{"content":"Go语言闭包研究 闭包是Go语言中一个非常抽象的概念，也是笔者在Go语言的学习过程中遇到的第一个难点，希望本文可以较为细致的将闭包的概念及特性介绍清楚。\n从函数变量说起 在Go语言中，函数也是一个变量，有类型、有值、有地址、可以被赋值、引用等，函数的零值为nil，但函数之间不能进行比较运算。\n什么是闭包 由于函数也是变量，自然的可以想到函数也是有地址的（对汇编和操作系统有一定了解后就会知道，每一次函数的调用都会在内存中为该函数分配一片区域，叫做栈帧），而闭包，就可以理解为将函数的地址赋值给了一个变量，又由于Go的变量会进行自动反向引用，所以可以将该变量也当作一个函数使用（且由于栈帧的概念，该变量中还保存着函数被赋值时的内部各个变量的状态）。下面给出例子对其进行展示：\npackage main import \u0026#34;fmt\u0026#34; func inc() func() int {\t//返回值为函数闭包  var x int return func() int { x++ return x } } func main(){ i := incr()\t//i被赋值为函数闭包，i内保存了x的状态  fmt.printLn(i())\t// 1  fmt.printLn(i())\t// 2  fmt.printLn(i())\t// 3  fmt.printLn(incr()())\t//1  fmt.printLn(incr()())\t//1  fmt.printLn(incr()())\t//1  return } 最开始的三个输出中，由于i内保存了x的状态，故每次对i的调用都会通过i内保存的指向x的指针修改x的值，且状态继续保存在i中，这种状态叫做x的逃逸，它的生命周期没有随着作用域的结束而结束。\n之后的三个输出时，由于每一次都调用一次incr()返回的一个闭包，故三次的x属于不同的栈帧，状态各自独立。\n闭包引用 理解了闭包的定义之后，对于闭包的引用也就自然而然了。闭包的引用其实就和其他变量的引用一样，只不过引用闭包之后得到的是一个保存了闭包声明时的状态的函数。需要注意的是，闭包对于外层词法域变量是引用的，也即，在闭包外部的变量修改可能会影响闭包内部的值，通过以下例子进行说明：\nx := 1 f := func() { println(x) }()\t//等价于定义之后调用一次f(), 输出1 x = 2 f()\t// 2 x = 3 f()\t// 3 每次调用f时都会对x解引用取值，因为闭包内保存的是x的地址。\n进阶实例 接下来给出一个较为复杂的例子，涉及到了闭包的循环引用，借此可以加深对闭包的特性的理解：\nvar funcSlice []func() for i := 0; i \u0026lt; 3; i++ { funcSlice = append(funcSlice, func() { println(i) }) } for j := 0; j \u0026lt; 3; j++ { funcSlice[j]() } 读者可以先思考一下这段代码最后会输出什么。\n5\n4\n3\n2\n1\n0\n这段代码最后的输出结果为3 3 3。\n感觉有点不理解了？这是正常的，让我们分析一下这段代码。\n首先是对funcSlice这个slice变量的声明，通过一个for循环，每次都在其末尾添加一个闭包，闭包内是将变量i输出。\n看到这个闭包的定义，是不是与之前那个输出x的函数一样？所以这里的i也是一个引用，闭包内实际上保存着的是i的地址，只不过在调用闭包函数时，自动解引用取了其保存的值，可以这样修改这段代码：\nvar funcSlice []func() for i := 0; i \u0026lt; 3; i++ { funcSlice = append(funcSlice, func() { println(\u0026amp;i) }) } for j := 0; j \u0026lt; 3; j++ { funcSlice[j]() } 看到的输出结果为0xc0000ac1d0 0xc0000ac1d0 0xc0000ac1d0，即每一次声明这个闭包得到的i的地址是一样的，故最后i的输出结果都是第一个for循环结束后i被赋予的值3。\n那么如果要让输出结果为1 2 3有什么方法呢？下面给出两种解决方案，这两种解决方案也是遇到大多数闭包引用问题时可以使用的方法。\n一、声明新变量 在返回的闭包内声明新变量：Output := i，并输出j，这样输出的就不再是对i的引用而是Output的值。修改后的代码为：\nvar funcSlice []func() for i := 0; i \u0026lt; 3; i++ { funcSlice = append(funcSlice, func() { Output := i println(Output) }) } for j := 0; j \u0026lt; 3; j++ { funcSlice[j]() } 二、声明新函数并传参 将代码修改为:\nvar funcSlice []func() for i := 0; i \u0026lt; 3; i++ { func(i int) { funcSlice = append(funcSlice, func() { println(i) })\t//闭包 \t}(i)\t//闭包并调用 } for j := 0; j \u0026lt; 3; j++ { funcSlice[j]()\t//调用 } 现在 println(i) 使用的 i 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。\n所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。\n思考题 希望通过本篇博客读者能对Go语言中的闭包有一定的掌握。\n可以自行尝试使用闭包是实现一个Fibonacci函数，其返回值为一个闭包，能返回连续的Fibonacci数。\n参考链接 Go语言闭包详解\n","date":"2021-01-04T15:28:37+08:00","permalink":"https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/","title":"Go语言闭包研究"},{"content":"LeetCode刷题笔记\u0026ndash;剑指Offer 10-I 题目：斐波那契数列 题目链接。\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：\nF(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n 示例 1：\n 输入：\nn = 2\n输出：\n1\n 示例2：\n 输入:\nn = 5\n输出:\n5\n限制：\n0 \u0026lt;= n \u0026lt;= 100\n题解 本题也是很经典的基础题，可以使用递归与非递归的解法。也可以选择保存Fibonacci数列的所有值或是只保存所求值。下面给出代码：\n递归解法 var fibs [101]int\t//保存Fibonacci数列中的各个元素值  func fib(n int) int { if fibs[n] != 0{ return fibs[n] % (1e9+7) } if n \u0026lt;= 1{\t//F(0) = 0, F(1) = 1  fibs[n] = n }else{\t//递归  fibs[n] = fib(n-1) + fib(n-2) } return fibs[n] % (1e9+7) } 执行用时: 0 ms\n内存消耗: 1.9 MB (1928 KB)\n非递归解法 func fib(n int) int { f0, f1 := 0, 1 for i := 0; i \u0026lt; n; i++ { f0,f1 = f1,(f0 + f1) % (1e9 + 7); } return f0 } 执行用时: 0 ms\n内存消耗: 1.9 MB (1924 KB)\n第二种解法执行用时及内存消耗均超过100%的用户。\n","date":"2021-01-03T14:23:11+08:00","permalink":"https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/","title":"LeetCode 剑指Offer 10-I"},{"content":"LeetCode刷题笔记\u0026ndash;剑指Offer 03 题目：数组中重复的数字 找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n 示例 1：\n 输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：\n2 或 3\n限制：\n2 \u0026lt;= n \u0026lt;= 100000\n题解 本题为基础题，难度不高，看到题目即可想到最为简单的暴力哈希解法，不过其实还存在更优解法，下面给予讨论。\n哈希表 直接使用一个map存放数字是否出现过，遍历整个slice，若数字对应的value为true则返回该数字，否则将其value置为true。\nfunc findRepeatNumber(nums []int) int { stat := make(map[int] bool) for _, val := range nums { if(stat[val]){ return val }else{ stat[val] = true } } return -1 } 执行用时: 48 ms\n内存消耗: 8.9 MB\n改进哈希法 由于数组的长度为n，而所有数字都在 0～n-1 的范围内，所以只需要构建一个大小为n的数组temp，nums内的值就是temp的下标，每次遍历到都将其对应的值加一，当该下标对应的值大于1的时候返回该下标。\nfunc findRepeatNumber(nums []int) int { n := len(nums) temp := make([]int, n) for i := 0; i\u0026lt;n;i++{ temp[nums[i]]++ if temp[nums[i]] \u0026gt; 1{ return nums[i] } } return -1 } 执行用时: 36 ms\n内存消耗: 8 MB\n排序+遍历 由于只需要找到重复数字，所以可以将nums内的元素排序后对其遍历，将当前数字与下一个数字进行比较，若相等则找到了重复数字，直接返回该值。\nfunc findRepeatNumber(nums []int) int { sort.Ints(nums) for sub, val := range nums{ if(val == nums[sub + 1]){ return val } } return -1 } 执行用时: 56 ms\n内存消耗: 8.7 MB\n","date":"2021-01-03T11:49:10+08:00","permalink":"https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/","title":"LeetCode 剑指Offer 03"},{"content":"Go语言学习之旅  Go语言是21世纪的C语言\n 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。\n本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。\n转载请注明出处。\nGo语言语法 函数 函数定义 func g() { } 需要注意的是，左花括号必须与函数名在同一行，否则无法通过编译。\n函数参数与返回值 函数可以接收多个参数，并返回多个值，且可以对返回值命名。\nfunc getX2AndX3_2(input int) (x2 int, x3 int) { x2 = 2 * input x3 = 3 * input // return x2, x3  return } 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名，如以下代码片段就会报错，因为error类型的返回值没有命名。\nfunc funcMui(x,y int)(sum int,error){ return x+y,nil } 如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。\n如果函数的最后一个参数使用...type的形式，则可以传入变长的参数。如果参数被储存在一个slice类型的变量slice中，则可以通过slice...的形式传递参数，调用变参函数。\npackage main import \u0026#34;fmt\u0026#34; func main() { x := min(1, 3, 2, 0) fmt.Printf(\u0026#34;The minimum is: %d\\n\u0026#34;, x) slice := []int{7,9,3,5,1} x = min(slice...) fmt.Printf(\u0026#34;The minimum in the slice is: %d\u0026#34;, x) } func min(s ...int) int { if len(s)==0 { return 0 } min := s[0] for _, v := range s { if v \u0026lt; min { min = v } } return min } /* Output: The minimum is: 0 The minimum in the slice is: 1 */ defer defer是Go中一个特殊的关键字，用于将某函数或是语句的执行顺序推迟到函数返回之前，使得函数在返回时进行一些操作，当有多个defer语句时，其执行顺序为先进后出。通过defer语句可以进行进程中止前的收尾，代码追踪，记录函数参数及返回值等功能，如以下的例子：\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; ) func func1(s string) (n int, err error) { defer func() { log.Printf(\u0026#34;func1(%q) = %d, %v\u0026#34;, s, n, err) }() return 7, io.EOF } func main() { func1(\u0026#34;Go\u0026#34;) } /* Output: 2021/1/2 22:46:11 func1(\u0026#34;Go\u0026#34;) = 7, EOF */ 内置函数 Go 语言拥有一些不需要进行导入操作就可以使用的内置函数，可以理解为某种类型的关键字，但是是以函数的方式实现的。以下给出一个简单的列表，之后会进行深入讨论：\n   名称 说明     close 用于管道通信   len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map）   new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。new() 是一个函数，不要忘记它的括号   copy、append 用于复制和连接切片   panic、recover 两者均用于错误处理机制   print、println 底层打印函数，在部署环境中建议使用 fmt 包   complex、real imag 用于创建和操作复数     未完待续\u0026hellip;\n ","date":"2020-12-30T18:45:11+08:00","permalink":"https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/","title":"Go语言学习之旅(二)"},{"content":"Go语言学习之旅  Go语言是21世纪的C语言\n 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。\n本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。\n转载请注明出处。\nGO语言的安装 Windows下的安装 由于本文作者主要使用的操作系统仍是Windows（没钱买Mac），故首先尝试的是在Windows下安装GO。\n进入GO语言官方下载地址，点击Microsoft Windows下方的下载链接自动下载最新的GO语言稳定版安装器。下载完成后运行选择Install即可完成安装。\n若安装过Windows下的包管理器如Scoop、Chocolatey等，也可以以使用指令：\nscoop install go 或是\nchoco install go 进行安装。\nLinux下的安装 本文作者目前使用的Linux发行版为Debian系下的Ubuntu 20.04和Deepin 20，故使用的指令均为Debian系下的操作。\n直接打开终端，输入\nsudo apt install golang 即可完成安装。\nGO语言的IDE 一个好的IDE可以使代码的编写事半功倍。本文作者使用的IDE为JetBrains推出的GoLand，平时对于小型代码的编写也会使用Visual Studio Code配上Go语言插件直接进行编写。\n两个软件的下载安装配置工作请读者自行学习，本文不再赘述。\nGO语言的语法 Go语言作为21世纪的C语言，许多语法特性与C语言类似，如需要对每个变量的类型都进行声明等，本文不对Go语言的语法基础细节做过多的说明，对于一些基本的语法使用只需参照官方文档或是任意一本参考书即可，本文只对作者学习过程中遇到的较为难以理解或是复杂的概念做一个记录说明。\n变量与常量声明 Go的常量声明使用const关键字：const identifier [type] = value\nGo的变量声明使用var关键字：var identifier type\n可以注意到的是，Go语言的变量声明与其他语言最为不同的一点是，类型放在变量名之后，这点在之后的各个地方都会被使用到，也是新手学习Go语言要跨过的第一个障碍。下面给出几个Go语言声明变量的例子：\nvar a int var b,c *int var d bool // 使用因式分解关键字写法，一般用于全局变量 var ( str string array []int ) 可以看出这样声明可以使得变量的类型定义清晰，每一行声明的变量都一定是同一个类型的。\nGo语言的 变量命名需要遵循骆驼命名法，如myArray和startDate。\nGo语言的变量在声明的时候会被赋予该类型的初值：int为0，float为0.0，bool为false，string为空字符串，指针为nil。Go中所有的变量都是经过初始化的。Go语言也支持变量在声明的时候进行初始化。同时，若在初始化时不指定类型，Go语言会根据初始化的值自动判断类型，但是没有初始化值且没有类型的变量声明是不被允许的。\n由于自动判断特性，Go语言在声明时支持简短声明语法:=，如a := 1，此时a自动被初始化成int型的变量，且值为1。（该种用法只能在一个代码块内对同一个变量名使用一次）\nGo语言也支持对多个变量同时声明或是同时赋值\na, b, c := 5, 7, \u0026#34;abc\u0026#34;\t//变量之前未被声明 d, e, f = 1, 3, \u0026#34;def\u0026#34;\t//变量之前已被声明 a, b = b, a\t//交换两个变量的值 _, b = 5, 7\t//使用只写变量\u0026#34;_\u0026#34;抛弃值 最后，在每个源文件中都支持包含一个init函数，支持对全局变量的初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。如下面的例子中便将Pi初始化为了3.1415\nvar Pi float64 func init() { Pi = 3.1415 } 字符串 与Python字符串类似，支持+拼接字符串，支持len(str)获取字符串长度，也支持str[]获取内容。若是导入了strings包或是strconv包则支持更多的特性。相关的函数接口功能参照该链接，做了较为详细的说明。\n指针 Go语言与C语言类似也有指针，但是Go语言的指针不允许进行指针算法，如pointer+2或是pointer++。\nGo的指针会进行自动反向引用，如\nv := 1 var p *int p = \u0026amp;v fmt.printLn(\u0026#34;v: %d p: %d p: %p\\n\u0026#34;,v, p, p)\t//Output: V: 1 p: 1 p: 0x24f0820 if-else结构 标准结构如下\nif condition1 { // do something\t} else if condition2 { // do something else\t} else { // catch-all or default } switch结构 Go语言中的switch结构接收任意形式的表达式，甚至可以不接收表达式，直接在case中使用语句进行判断（而非C语言一样之能接收整型数据），且不需要使用break语句来结束，当需要继续执行后面的代码时，可以使用fallthrough关键字来达到目的。\nswitch a, b := x[i], y[j]; { case a \u0026lt; b: t = -1 case a == b: t = 0 case a \u0026gt; b: fallthrough case default: t = 1 } 在上面这个代码片段中，变量 a 和 b 被平行初始化，然后作为判断条件。\nfor结构 基本用法与C语言类似，只是不需要小括号。\nfor是Go语言提供的唯一一种循环结构，Go语言没有while或是do-while循环，因为都可以以for循环的形式实现。\nGo也支持一种特殊的迭代结构for-range，一般形式为：for ix, val := range coll {}。其中val是集合中对应值的拷贝，对其的修改不会改变原集合中的值。\n 未完待续\u0026hellip;\n ","date":"2020-12-30T17:45:11+08:00","permalink":"https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/","title":"Go语言学习之旅(一)"}]