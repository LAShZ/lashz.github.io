<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lavch&#39;s blog</title>
    <link>https://lashz.github.io/post/</link>
    <description>Recent content in Posts on Lavch&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Jan 2021 23:27:26 +0800</lastBuildDate><atom:link href="https://lashz.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 剑指Offer 10-II</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-ii/</link>
      <pubDate>Wed, 06 Jan 2021 23:27:26 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-ii/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 10-II 题目：青蛙跳台阶问题 题目链接。
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 示例 1：
 输入：
n = 2
输出：
2
 示例2：
 输入:
n = 7
输出:
21
 示例3：
 输入:
n = 0
输出:
1
限制：
0 &amp;lt;= n &amp;lt;= 100
题解 本题是Fibonacci数列的变种题，只需理解，对于第n级台阶，可以一次跳上1级到，也可以一次跳上2级到，所以递推公式为f(n) = f(n-1) + f(n-2)，且由于n = 0时输出为1，所以f(0) = f(1) = 1。下面给出代码：
func numWays(n int) int { a,b:=1,1 for i:=1;i&amp;lt;=n;i++{ a,b=b,(a+b)%(1e9+7) } return a } 执行用时: 0 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指offer 09</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-09/</link>
      <pubDate>Wed, 06 Jan 2021 15:13:33 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-09/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 09 题目：用两个栈实现队列 题目链接。
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
 示例1
 输入：
[&amp;ldquo;CQueue&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;] [[],[3],[],[]]
输出：
[null,null,3,-1]
 示例2
 输入：
[&amp;ldquo;CQueue&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;] [[],[],[5],[2],[],[]]
输出：
[null,-1,null,null,5,2]
限制:
 1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  题解 本题比较经典，使用两个栈实现队列。
维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。
根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。过程如图所示：
Go语言没有单独的栈的数据结构，所以可以选择数组或是链表的形式进行存储。
数组形式 使用两个栈stack1, stack2。添加元素时，将元素加入stack1栈顶。取元素时，首先判断stack2是否为空，若为空则将 stack1 里的所有元素弹出插入到 stack2 里，如果 stack2 仍为空，则返回 -1，否则从 stack2 弹出一个元素并返回。
type CQueue struct { stack1, stack2 []int } func Constructor() CQueue { return CQueue{} } func (this *CQueue) AppendTail(value int) { this.</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 07</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-07/</link>
      <pubDate>Tue, 05 Jan 2021 19:50:31 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-07/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 07 题目：重建二叉树 题目链接。
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
 示例
 输入：
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
输出：
 3 / \ 9 20 / \ 15 7 限制:
0 &amp;lt;= 节点个数 &amp;lt;= 5000
题解 本题难度不高，主要是对于二叉树的遍历方式的掌握。
前序遍历是先遍历根节点，然后遍历左子树，最后遍历右子树。
中序遍历是先遍历左子树，然后遍历根节点，最后遍历右子树。
后续遍历是先遍历左子树，然后遍历右子树，最后遍历根节点。
所以，可以通过前序遍历，找到二叉树的根节点，再通过找到的根节点，在中序遍历序列中，将树在根节点的前后划分为左子树和右子树，最后对子树进行递归或是迭代，直到将所有节点都插入树内。
以给出的示例为例，首先通过前序遍历序列的第一个值preorder[0] = 3知道根节点为3，然后在中序遍历序列中找到值为3的节点inorder[1]，这样就知道了左子树的节点为[9]，右子树的节点为[15,20,7]。因为preorder[0]为根节点，且由中序遍历可知，左子树加上根节点的节点数序号为index = 1（从0开始计数），所以左子树的节点为preorder[1: index+1]或是inorder[:index]，右子树的节点为preorder[index+1: ]或是inorder[index+1:]。
下面给出递归和迭代两种方法的代码。
递归法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } root := &amp;amp;TreeNode{Val:preorder[0]}	// 建树  var index int for i := range inorder{ if inorder[i]==preorder[0]{	// 找到根节点  index = i break } } root.</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 06</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-06/</link>
      <pubDate>Tue, 05 Jan 2021 11:24:07 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-06/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 06 题目：从尾到头打印链表 题目链接。
输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
 示例
 输入：
head = [1, 3, 2]
输出：
[2, 3, 1]
限制:
0 &amp;lt;= 链表长度 &amp;lt;= 10000
题解 本题最容易想到的就是使用一个栈，利用栈先进后出的特性将链表内的值都放入，然后再从栈中取出放入数组内，即可实现倒序输出。不过由于Go语言并无现成的栈的数据结构，且要自己实现显得整到题目的代码较为臃肿，故可以使用别的方法。下面给出我的两种思路（其实归根结底还是用的栈）
利用defer和匿名函数 虽然Go语言中并无现成的栈的数据结构，但是Go语言的defer的执行顺序为先进后出（关于defer的介绍可以参考博主的这篇博客，关于匿名函数和闭包的介绍可以参考博主的这篇博客），因此我们可以利用这个特性，循环到链表的每一个节点时，都通过defer调用一个匿名函数，匿名函数的功能为将该节点的值加到数组尾部。当函数执行到return语句时，就按照倒序将链表的值放入了数组中。需要注意的一点是，使用这种方式时，函数的返回值必须命名，否则执行完return语句后函数将返回一个空值，而不会把所有defer执行完成后的数组返回。下面给出代码：
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) (list []int) { for ; head != nil; head = head.Next { temp := head.Val defer func() { list = append(list, temp) }() } return } 执行用时: 4 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 05</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-05/</link>
      <pubDate>Mon, 04 Jan 2021 21:54:24 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-05/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 05 题目：把数字翻译成字符串 题目链接。
请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
 示例
 输入：
s = &amp;ldquo;We are happy.&amp;rdquo;
输出：
&amp;ldquo;We%20are%20happy.&amp;rdquo;
限制:
0 &amp;lt;= s 的长度 &amp;lt;= 10000
题解 直接使用strings下的Replaces接口函数即可。
函数声明为: func Replace(s, old, new string, n int) string
功能为: 返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&amp;lt;0会替换所有old子串。
代码：
func replaceSpace(s string) string { return strings.Replace(s, &amp;#34; &amp;#34;, &amp;#34;%20&amp;#34;, -1) } 执行用时: 0 ms
内存消耗: 1.9 MB</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 04</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</link>
      <pubDate>Mon, 04 Jan 2021 19:39:31 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 04 题目：二维数组中的查找 题目链接。
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
 示例
 现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &amp;lt;= n &amp;lt;= 1000
0 &amp;lt;= m &amp;lt;= 1000
题解 这道题最简单的做法就是遍历整个数组，每一个元素都拿来比较，找到了就返回true，遍历完之后还没找到就返回false，但这种方法的时间复杂度为O(NM)，且并未利用数组内元素递增的特点。
对于这道题我们先将数组画出来，可以发现对于任意一个元素，总是要大于它的左下方的元素。
所以，我们可以先在第一行进行搜索，找到第一个大于目标值的数，然后一直朝着左下方搜索，该处的值大于目标值就朝左，小于目标值就朝右。整个搜索过程中，找到对应值就返回true，超出边界就立即停止搜索，并返回false。在上图中搜索14的过程如下图所示：
程序代码如下：
func findNumberIn2DArray(matrix [][]int, target int) bool { i := 0 if (len(matrix) == 0 || len(matrix[0]) == 0) {	// 为空数组直接返回false  return false } for ; ((i &amp;lt; len(matrix[0]) - 1) &amp;amp;&amp;amp; matrix[0][i] &amp;lt; target); i++ {	// 在第一行大于target的或是超出边界 	} for j := 0; ; { if i &amp;lt; 0 || j &amp;gt; (len(matrix)-1) { return false } if matrix[j][i] == target { return true } else if matrix[j][i] &amp;gt; target {	// 朝左  i-- } else {	// 朝下  j++ } } } 执行用时: 24 ms</description>
    </item>
    
    <item>
      <title>Go语言闭包研究</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Mon, 04 Jan 2021 15:28:37 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/</guid>
      <description>Go语言闭包研究 闭包是Go语言中一个非常抽象的概念，也是笔者在Go语言的学习过程中遇到的第一个难点，希望本文可以较为细致的将闭包的概念及特性介绍清楚。
从函数变量说起 在Go语言中，函数也是一个变量，有类型、有值、有地址、可以被赋值、引用等，函数的零值为nil，但函数之间不能进行比较运算。
什么是闭包 由于函数也是变量，自然的可以想到函数也是有地址的（对汇编和操作系统有一定了解后就会知道，每一次函数的调用都会在内存中为该函数分配一片区域，叫做栈帧），而闭包，就可以理解为将函数的地址赋值给了一个变量，又由于Go的变量会进行自动反向引用，所以可以将该变量也当作一个函数使用（且由于栈帧的概念，该变量中还保存着函数被赋值时的内部各个变量的状态）。下面给出例子对其进行展示：
package main import &amp;#34;fmt&amp;#34; func inc() func() int {	//返回值为函数闭包  var x int return func() int { x++ return x } } func main(){ i := incr()	//i被赋值为函数闭包，i内保存了x的状态  fmt.printLn(i())	// 1  fmt.printLn(i())	// 2  fmt.printLn(i())	// 3  fmt.printLn(incr()())	//1  fmt.printLn(incr()())	//1  fmt.printLn(incr()())	//1  return } 最开始的三个输出中，由于i内保存了x的状态，故每次对i的调用都会通过i内保存的指向x的指针修改x的值，且状态继续保存在i中，这种状态叫做x的逃逸，它的生命周期没有随着作用域的结束而结束。
之后的三个输出时，由于每一次都调用一次incr()返回的一个闭包，故三次的x属于不同的栈帧，状态各自独立。
闭包引用 理解了闭包的定义之后，对于闭包的引用也就自然而然了。闭包的引用其实就和其他变量的引用一样，只不过引用闭包之后得到的是一个保存了闭包声明时的状态的函数。需要注意的是，闭包对于外层词法域变量是引用的，也即，在闭包外部的变量修改可能会影响闭包内部的值，通过以下例子进行说明：
x := 1 f := func() { println(x) }()	//等价于定义之后调用一次f(), 输出1 x = 2 f()	// 2 x = 3 f()	// 3 每次调用f时都会对x解引用取值，因为闭包内保存的是x的地址。</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 10-I</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</link>
      <pubDate>Sun, 03 Jan 2021 14:23:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 10-I 题目：斐波那契数列 题目链接。
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 示例 1：
 输入：
n = 2
输出：
1
 示例2：
 输入:
n = 5
输出:
5
限制：
0 &amp;lt;= n &amp;lt;= 100
题解 本题也是很经典的基础题，可以使用递归与非递归的解法。也可以选择保存Fibonacci数列的所有值或是只保存所求值。下面给出代码：
递归解法 var fibs [101]int	//保存Fibonacci数列中的各个元素值  func fib(n int) int { if fibs[n] !</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 03</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</link>
      <pubDate>Sun, 03 Jan 2021 11:49:10 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 03 题目：数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
 示例 1：
 输入：
[2, 3, 1, 0, 2, 5, 3]
输出：
2 或 3
限制：
2 &amp;lt;= n &amp;lt;= 100000
题解 本题为基础题，难度不高，看到题目即可想到最为简单的暴力哈希解法，不过其实还存在更优解法，下面给予讨论。
哈希表 直接使用一个map存放数字是否出现过，遍历整个slice，若数字对应的value为true则返回该数字，否则将其value置为true。
func findRepeatNumber(nums []int) int { stat := make(map[int] bool) for _, val := range nums { if(stat[val]){ return val }else{ stat[val] = true } } return -1 } 执行用时: 48 ms
内存消耗: 8.9 MB</description>
    </item>
    
    <item>
      <title>Go语言学习之旅(二)</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/</link>
      <pubDate>Wed, 30 Dec 2020 18:45:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/</guid>
      <description>Go语言学习之旅  Go语言是21世纪的C语言
 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。
本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。
转载请注明出处。
Go语言语法 函数 函数定义 func g() { } 需要注意的是，左花括号必须与函数名在同一行，否则无法通过编译。
函数参数与返回值 函数可以接收多个参数，并返回多个值，且可以对返回值命名。
func getX2AndX3_2(input int) (x2 int, x3 int) { x2 = 2 * input x3 = 3 * input // return x2, x3  return } 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名，如以下代码片段就会报错，因为error类型的返回值没有命名。
func funcMui(x,y int)(sum int,error){ return x+y,nil } 如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。
如果函数的最后一个参数使用...type的形式，则可以传入变长的参数。如果参数被储存在一个slice类型的变量slice中，则可以通过slice...的形式传递参数，调用变参函数。
package main import &amp;#34;fmt&amp;#34; func main() { x := min(1, 3, 2, 0) fmt.Printf(&amp;#34;The minimum is: %d\n&amp;#34;, x) slice := []int{7,9,3,5,1} x = min(slice.</description>
    </item>
    
    <item>
      <title>Go语言学习之旅(一)</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/</link>
      <pubDate>Wed, 30 Dec 2020 17:45:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/</guid>
      <description>Go语言学习之旅  Go语言是21世纪的C语言
 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。
本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。
转载请注明出处。
GO语言的安装 Windows下的安装 由于本文作者主要使用的操作系统仍是Windows（没钱买Mac），故首先尝试的是在Windows下安装GO。
进入GO语言官方下载地址，点击Microsoft Windows下方的下载链接自动下载最新的GO语言稳定版安装器。下载完成后运行选择Install即可完成安装。
若安装过Windows下的包管理器如Scoop、Chocolatey等，也可以以使用指令：
scoop install go 或是
choco install go 进行安装。
Linux下的安装 本文作者目前使用的Linux发行版为Debian系下的Ubuntu 20.04和Deepin 20，故使用的指令均为Debian系下的操作。
直接打开终端，输入
sudo apt install golang 即可完成安装。
GO语言的IDE 一个好的IDE可以使代码的编写事半功倍。本文作者使用的IDE为JetBrains推出的GoLand，平时对于小型代码的编写也会使用Visual Studio Code配上Go语言插件直接进行编写。
两个软件的下载安装配置工作请读者自行学习，本文不再赘述。
GO语言的语法 Go语言作为21世纪的C语言，许多语法特性与C语言类似，如需要对每个变量的类型都进行声明等，本文不对Go语言的语法基础细节做过多的说明，对于一些基本的语法使用只需参照官方文档或是任意一本参考书即可，本文只对作者学习过程中遇到的较为难以理解或是复杂的概念做一个记录说明。
变量与常量声明 Go的常量声明使用const关键字：const identifier [type] = value
Go的变量声明使用var关键字：var identifier type
可以注意到的是，Go语言的变量声明与其他语言最为不同的一点是，类型放在变量名之后，这点在之后的各个地方都会被使用到，也是新手学习Go语言要跨过的第一个障碍。下面给出几个Go语言声明变量的例子：
var a int var b,c *int var d bool // 使用因式分解关键字写法，一般用于全局变量 var ( str string array []int ) 可以看出这样声明可以使得变量的类型定义清晰，每一行声明的变量都一定是同一个类型的。
Go语言的 变量命名需要遵循骆驼命名法，如myArray和startDate。
Go语言的变量在声明的时候会被赋予该类型的初值：int为0，float为0.0，bool为false，string为空字符串，指针为nil。Go中所有的变量都是经过初始化的。Go语言也支持变量在声明的时候进行初始化。同时，若在初始化时不指定类型，Go语言会根据初始化的值自动判断类型，但是没有初始化值且没有类型的变量声明是不被允许的。</description>
    </item>
    
  </channel>
</rss>
