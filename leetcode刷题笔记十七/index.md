# LeetCode 剑指Offer 19


<!--more-->

## 题目：正则表达式匹配

[题目链接](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

请实现一个函数用来匹配包含`'. '`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但与`"aa.a"`和`"ab*a"`均不匹配。

> 示例1

**输入**：

s = "aa"
p = "a"

**输出**：

false

**解释**: 

 "a" 无法匹配 "aa" 整个字符串。

> 示例2

**输入**：

s = "aa"
p = "a*"

**输出**：

true

**解释**：

因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

> 示例3

**输入**：

s = "ab"
p = ".*"

**输出**：

true

**解释**：

".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

> 示例4

**输入**：

s = "aab"
p = "c\*a\*b"

**输出**：

true

**解释**：

因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。

> 示例5

**输入**：

s = "mississippi"
p = "mis\*is\*p\*."

**输出**：

false

> **说明**:

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母以及字符 `.` 和 `*`，无连续的 `'*'`。

## 题解

本题为困难题，需要一定的理解与算法思想。

正则匹配最先想到的由正则表达式构建自然是有限状态机，不过由于本题只有两种模式字符，故本题可以直接使用DP或是递归解法求解。

### 动规解法

设`f[i][j]`为字符串s的前i个字符与模式串p的前j个字符是否匹配。观察模式串p可以发现，模式串的字符有三种情况：正常字符、‘\*’、和‘\.’，针对这三种情况讨论：

1. 若当前模式串的字符为正常字符: 代表当前不是正则匹配模式，首先匹配模式串与字符串字符，若相等，则当前状态等于上一个字符的状态，即f\[i][j]=f\[i-1][j-1]
2. 若当前模式串的字符为'\.': 代表当前为任意字符匹配模式，直接看f\[i-1][j-1]是否匹配，即f\[i][j]=f\[i-1][j-1]
3. 若当前模式串的字符为'\*': 代表当前为前一字符出现任意次模式，假设p[j-1]=='c'，即当前的正则匹配为"c\*"，则分为两种情况：
   - 若出现0次，即当前字符串的字符不等于'c'，则直接舍弃模式串的"c\*"，即f\[i][j]=f\[i][j-2]
   - 若出现大于1次，即当前字符串的字符等于'c'，则模式串无需移动，字符串前移一个重新匹配，即f\[i][j]=f\[i-1][j]

由此得到DP的转移方程为：
$$
f[i][j]=\begin{cases}
	{f[i-1][j-1]} &\text{if }{p[j]\neq'\*'} \\cr
	\begin{cases}
	{f[i][j-1]} &\text{if }{p[j-1]\neq{s[i]}} \\cr
	{f[i-1][j]} &\text{if }{p[j-1]=s[i]}
	\end{cases}=>&\text{if }{p[j]='\*'}
\end{cases}
$$

初始条件为f\[0][0]=true，f\[i][0]=false (i != 0)，即空模式串与空字符串是匹配的，但是空模式串与非空字符串必定是不匹配的。

最后的代码如下：

```go

func isMatch(s string, p string) bool {
	slen := len(s)
	plen := len(p)
	dp := make([][]bool, slen+1)
	for i := 0; i <= slen; i++ {
		dp[i] = make([]bool, plen+1)
	}

	for i := 0; i <= slen; i++ {
		for j := 0; j < plen+1; j++ {
			if j == 0 {
				dp[i][j] = (i == 0)
			} else {
				if p[j-1] != '*' {
					if i > 0 && (s[i-1] == p[j-1] || p[j-1] == '.') {
						dp[i][j] = dp[i-1][j-1]
					}
				} else {
					if j >= 2 {
						dp[i][j] = dp[i][j-2] || dp[i][j]
					}
					if i >= 1 && j >= 2 && (s[i-1] == p[j-2] || p[j-2] == '.') {
						dp[i][j] = dp[i-1][j] || dp[i][j]
					}
				}
			}
		}
	}
	return dp[slen][plen]
}
```

> 执行用时: 0 ms
>
> 内存消耗: 2.4 MB

### 递归解法

与DP思路类似，不过每一次判断完当前字符是否匹配后，将其从字符串中剔除，然后将新的字符串传入isMatch函数进行递归。

```go
func isMatch(s string, p string) bool {
	slen := len(s)
	plen := len(p)

	// 若字符串长度为0
	if slen == 0 {
		// 若模式串长度为奇数，必定不匹配
		if plen%2 != 0 {
			return false
		}
		for i := 1; i < plen; i += 2 {
			// 若不是"c*"形式，必定不匹配
			if p[i] != '*' {
				return false
			}
		}
		return true
	}

	// 若模式串长度为0，且字符串长度不为0，必定不匹配
	if plen == 0 {
		return false
	}

	c1 := s[0]
	c2 := p[0]
	var c3 byte
	// 若模式串长度大于1，则后一个字符有可能为'*'，需要记录
	if plen > 1 {
		c3 = p[1]
	}
	// 若不为"c*"模式
	if c3 != '*' {
		// 匹配，剔除当前匹配字符，递归
		if c1 == c2 || c2 == '.' {
			return isMatch(s[1:], p[1:])
		}
		// 不匹配，直接返回false
		return false
	}

	// 若为"c*"模式且匹配
	if c1 == c2 || c2 == '.' {
		return isMatch(s[1:], p) || isMatch(s, p[2:])
	}
	// 若为"c*"模式且不匹配
	return isMatch(s, p[2:])
}
```

> 执行用时: 12 ms
>
> 内存消耗: 2.1 MB
