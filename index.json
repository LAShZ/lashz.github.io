[{"categories":["刷题笔记"],"content":"表示数值的字符串","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 20","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB/"},{"categories":["刷题笔记"],"content":"题目：表示数值的字符串 题目链接 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\"、“5e2”、\"-123\"、“3.1416”、\"-1E-16\"、“0123\"都表示数值，但\"12e”、“1a3.14”、“1.2.3”、\"+-5\"及\"12e+5.4\"都不是。 ","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 20","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB/"},{"categories":["刷题笔记"],"content":"题解 利用有限状态机的思想，只需要判断是否为数字，是否为小数，是否为指数，是否为符号即可。 func isNumber(s string) bool { isNum := false // 是否为数字 isDec := false // 是否为小数 isIndex := false // 是否为指数 hasPreNum := false // 指数前是否有数字 s = strings.TrimSpace(s) s = strings.ToLower(s) for i, v := range s { if v \u003e= '0' \u0026\u0026 v \u003c= '9' { isNum = true if !isIndex { hasPreNum = true } } else if v == '.' \u0026\u0026 !isDec \u0026\u0026 !isIndex { isDec = true } else if v == 'e' \u0026\u0026 !isIndex \u0026\u0026 isNum { isIndex = true isNum = false // 这里需要将isNum置false，因为指数后面若没有数字的话最后结果也应该为假 } else if (v == '+' || v == '-') \u0026\u0026 (i == 0 || s[i-1] == 'e') { } else { return false } } return isNum \u0026\u0026 hasPreNum } 执行用时: 0 ms 内存消耗: 2.3 MB ","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 20","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AB/"},{"categories":["刷题笔记"],"content":"正则表达式匹配","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 19","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/"},{"categories":["刷题笔记"],"content":"题目：正则表达式匹配 题目链接 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。 示例1 输入： s = “aa” p = “a” 输出： false 解释: “a” 无法匹配 “aa” 整个字符串。 示例2 输入： s = “aa” p = “a*” 输出： true 解释： 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。 示例3 输入： s = “ab” p = “.*” 输出： true 解释： “.” 表示可匹配零个或多个（''）任意字符（'.'）。 示例4 输入： s = “aab” p = “c*a*b” 输出： true 解释： 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。 示例5 输入： s = “mississippi” p = “mis*is*p*.” 输出： false 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。 ","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 19","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/"},{"categories":["刷题笔记"],"content":"题解 本题为困难题，需要一定的理解与算法思想。 正则匹配最先想到的由正则表达式构建自然是有限状态机，不过由于本题只有两种模式字符，故本题可以直接使用DP或是递归解法求解。 ","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 19","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/"},{"categories":["刷题笔记"],"content":"动规解法 设f[i][j]为字符串s的前i个字符与模式串p的前j个字符是否匹配。观察模式串p可以发现，模式串的字符有三种情况：正常字符、‘*’、和‘.’，针对这三种情况讨论： 若当前模式串的字符为正常字符: 代表当前不是正则匹配模式，首先匹配模式串与字符串字符，若相等，则当前状态等于上一个字符的状态，即f[i][j]=f[i-1][j-1] 若当前模式串的字符为'.': 代表当前为任意字符匹配模式，直接看f[i-1][j-1]是否匹配，即f[i][j]=f[i-1][j-1] 若当前模式串的字符为'*': 代表当前为前一字符出现任意次模式，假设p[j-1]==‘c’，即当前的正则匹配为\"c*\"，则分为两种情况： 若出现0次，即当前字符串的字符不等于’c'，则直接舍弃模式串的\"c*\"，即f[i][j]=f[i][j-2] 若出现大于1次，即当前字符串的字符等于’c'，则模式串无需移动，字符串前移一个重新匹配，即f[i][j]=f[i-1][j] 由此得到DP的转移方程为： $$ f[i][j]=\\begin{cases} {f[i-1][j-1]} \u0026\\text{if }{p[j]\\neq'*'} \\cr \\begin{cases} {f[i][j-1]} \u0026\\text{if }{p[j-1]\\neq{s[i]}} \\cr {f[i-1][j]} \u0026\\text{if }{p[j-1]=s[i]} \\end{cases}=\u003e\u0026\\text{if }{p[j]='*'} \\end{cases} $$ 初始条件为f[0][0]=true，f[i][0]=false (i != 0)，即空模式串与空字符串是匹配的，但是空模式串与非空字符串必定是不匹配的。 最后的代码如下： func isMatch(s string, p string) bool { slen := len(s) plen := len(p) dp := make([][]bool, slen+1) for i := 0; i \u003c= slen; i++ { dp[i] = make([]bool, plen+1) } for i := 0; i \u003c= slen; i++ { for j := 0; j \u003c plen+1; j++ { if j == 0 { dp[i][j] = (i == 0) } else { if p[j-1] != '*' { if i \u003e 0 \u0026\u0026 (s[i-1] == p[j-1] || p[j-1] == '.') { dp[i][j] = dp[i-1][j-1] } } else { if j \u003e= 2 { dp[i][j] = dp[i][j-2] || dp[i][j] } if i \u003e= 1 \u0026\u0026 j \u003e= 2 \u0026\u0026 (s[i-1] == p[j-2] || p[j-2] == '.') { dp[i][j] = dp[i-1][j] || dp[i][j] } } } } } return dp[slen][plen] } 执行用时: 0 ms 内存消耗: 2.4 MB ","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/:2:1","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 19","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/"},{"categories":["刷题笔记"],"content":"递归解法 与DP思路类似，不过每一次判断完当前字符是否匹配后，将其从字符串中剔除，然后将新的字符串传入isMatch函数进行递归。 func isMatch(s string, p string) bool { slen := len(s) plen := len(p) // 若字符串长度为0 if slen == 0 { // 若模式串长度为奇数，必定不匹配 if plen%2 != 0 { return false } for i := 1; i \u003c plen; i += 2 { // 若不是\"c*\"形式，必定不匹配 if p[i] != '*' { return false } } return true } // 若模式串长度为0，且字符串长度不为0，必定不匹配 if plen == 0 { return false } c1 := s[0] c2 := p[0] var c3 byte // 若模式串长度大于1，则后一个字符有可能为'*'，需要记录 if plen \u003e 1 { c3 = p[1] } // 若不为\"c*\"模式 if c3 != '*' { // 匹配，剔除当前匹配字符，递归 if c1 == c2 || c2 == '.' { return isMatch(s[1:], p[1:]) } // 不匹配，直接返回false return false } // 若为\"c*\"模式且匹配 if c1 == c2 || c2 == '.' { return isMatch(s[1:], p) || isMatch(s, p[2:]) } // 若为\"c*\"模式且不匹配 return isMatch(s, p[2:]) } 执行用时: 12 ms 内存消耗: 2.1 MB ","date":"2021-01-24","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/:2:2","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 19","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%83/"},{"categories":["刷题笔记"],"content":"删除链表的节点","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 18","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD/"},{"categories":["刷题笔记"],"content":"题目：删除链表的节点 题目链接 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 示例1 输入： head = [4,5,1,9], val = 5 输出： [4,1,9] 示例2 输入： head = [4,5,1,9], val = 1 输出： [4,5,9] 说明: 题目保证链表中节点的值互不相同 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 18","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD/"},{"categories":["刷题笔记"],"content":"题解 遍历找到节点和前驱节点，然后将前驱节点的Next指针指向找到的节点的下一个节点即可，无需考虑内存回收问题。 需要注意若为空链表或是找到的节点为头节点时的情况要单独考虑。 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(head *ListNode, val int) *ListNode { if head == nil { return nil } if head.Val == val { head = head.Next return head } prior := head next := prior.Next for next != nil { if next.Val == val { prior.Next = next.Next return head } prior = prior.Next next = next.Next } return head } 执行用时: 0 ms 内存消耗: 2.8 MB 也可以采用递归的形式，每一次都只考虑头节点，然后将当前头节点的子链表递归，下面给出递归代码 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteNode(head *ListNode, val int) *ListNode { if head == nil { return nil } if head.Val == val { return head.Next } head.Next = deleteNode(head.Next, val) return head } 执行用时: 4 ms 内存消耗: 3 MB ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 18","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%85%AD/"},{"categories":["刷题笔记"],"content":"打印从1到最大的n位数","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 17","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/"},{"categories":["刷题笔记"],"content":"题目：打印从1到最大的n位数 题目链接 输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。 示例 1： 输入： n=1 输出： [1,2,3,4,5,6,7,8,9] ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 17","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/"},{"categories":["刷题笔记"],"content":"题解 先通过$10^{n-1}+9$获取需要的切片大小，然后循环将数字填入即可。 func printNumbers(n int) []int { max := 0 for ; n \u003e 0; n-- { max = max*10 + 9 } res := make([]int, max) for i := 1; i \u003c= max; i++ { res[i-1] = i } return res } 执行用时: 8 ms 内存消耗: 7 MB ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 17","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/"},{"categories":["刷题笔记"],"content":"进阶 上述AC代码未考虑大数越界的情况，虽然测试集中没有，但是仍然是一个非常值得思考的问题。 未完待续… ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/:3:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 17","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%94/"},{"categories":["刷题笔记"],"content":"二进制中1的个数","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 16","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B/"},{"categories":["刷题笔记"],"content":"题目：数值的整数次方 题目链接 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1： 输入： 2.00000, 10 输出： 1024.00000 示例2： 输入: 2.10000, 3 输出: 9.26100 示例3： 输入: 2.00000, -2 输出: 31 限制： -100.0 \u003c x \u003c 100.0 n是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 16","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B/"},{"categories":["刷题笔记"],"content":"题解 使用快速幂乘法，通过以下公式不断递归： $$ x^n = \\begin{cases} {(x^2)^{\\frac{n}{2}}} \u0026{n为偶数} \\cr %这里要加cr不然在博客中无法显示，但是加了会导致typora中显示多一个cr {x*(x^2)^{\\frac{n}{2}}} \u0026{n为奇数} \\end{cases} $$ 同时使用位操作，用n\u003e\u003e1代替n/2，用n\u00260x1代替n%2，得到最后代码如下： func myPow(x float64, n int) float64 { if n == 0{ return 1 } if n == 1{ return x } if n\u003c0{ x = 1/x n = -n } temp := myPow(x , n\u003e\u003e2) if n\u00260x1 == 0{ return temp*temp } return x*temp*temp } 执行用时: 0 ms 内存消耗: 2.1 MB ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 16","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E5%9B%9B/"},{"categories":["刷题笔记"],"content":"二进制中1的个数","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 15","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89/"},{"categories":["刷题笔记"],"content":"题目：二进制中1的个数 题目链接 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 输入： 00000000000000000000000000001011 输出： 3 解释: 输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。 示例2： 输入: 00000000000000000000000010000000 输出: 1 解释: 输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。 示例3： 输入: 11111111111111111111111111111101 输出: 31 解释: 输入的二进制串11111111111111111111111111111101中，共有32位为 ‘1’。 限制： 输入必须是长度为 32 的 二进制串 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 15","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89/"},{"categories":["刷题笔记"],"content":"题解 直接按位判断即可。 func hammingWeight(num uint32) int { var sum uint32 for num != 0 { sum += (num \u0026 0x1) num = num \u003e\u003e 1 } return int(sum) } 执行用时: 0 ms 内存消耗: 1.9 MB 看到一个牛逼的解法： (n−1) 解析： 二进制数字n最右边的1变成0，此1右边的0都变成1。 n \u0026 (n - 1)解析： 二进制数字n最右边的1变成0，其余不变。 故只需要: 初始化数量统计变量 res。 循环消去最右边的1：当 n = 0 时跳出。 res += 1 ： 统计变量加1； n \u0026= n - 1 ： 消去数字n最右边的1 。 返回统计数量 res 。 func hammingWeight(num uint32) int { sum := 0 for num != 0 { sum++ num \u0026= num-1 } return sum } 执行用时: 0 ms 内存消耗: 1.9 MB 该解法时间复杂度要优于第一种解法。 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 15","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%89/"},{"categories":["刷题笔记"],"content":"剪绳子I \u0026\u0026 剪绳子II","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 14","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"题目：剪绳子I \u0026\u0026 剪绳子II 题目链接: 剪绳子I 剪绳子II 给你一根长度为n的绳子，请把绳子剪成整数长度的m段（m、n都是整数，n\u003e1并且m\u003e1），每段绳子的长度记为k[0],k[1]...k[m - 1]。请问k[0]*k[1]*...*k[m - 1]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 剪绳子II的答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入： 2 输出： 1 示例2： 输入: 10 输出: 36 (解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36) 限制： 2 \u003c= n \u003c= 1000 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 14","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"题解 本题其实为一道数学题。 将长度为n的绳子切成a段： $$ n = n_1+n_2+…+n_a $$ 等价于求: $$ max(n_1*n_2*…*n_a) $$ 下面进行推导证明：当全部切成长度为3的绳段时乘积最大 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 14","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"推导 由均值不等式： $$ \\frac{n_1+n_2+…+n_a}{a} \\geqslant \\sqrt[{a}]{n_1n_2…n_a} $$ 可以知道当$ n_1=n_2=…=n_a $时乘积最大，此时每一段绳子的长度都为$ \\frac{n}{a} $，乘积为$ x^a $。且由： $$ x^{{a}}=x^{\\frac{{n}}{{x}}}=(x^{\\frac{1}{{x}}})^{{n}} $$ 可知只需求出$ x^{\\frac{1}{x}} $的最大值即可。通过求导可知当$ x=\\textit{e} $时取得最大值，又由于$x$必须为整数，故取得$x=3$时得到的结果最大。又由于n不一定能被整除，故当余数为1时需要将3+1的情况替换为乘积更大的2+2。 对于剪绳子II，因为得到的数可能极大，故需要考虑越界问题，对每一步中间结果取余，且对于得到的指数也需要判断是否超范围。 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/:2:1","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 14","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"AC代码 剪绳子I: func cuttingRope(n int) int { if n \u003c 4 { return n - 1 } if n == 4 { return 4 } ans := int(math.Pow(3, float64(n/3))) remain := n % 3 if remain == 1 { ans = ans / 3 * 4 } if remain == 2 { ans = ans * 2 } return ans } 执行用时: 0 ms 内存消耗: 1.9 MB 剪绳子II: func cuttingRope(n int) int { if n \u003c= 3 { return n - 1 } factor := n / 3 - 1 maxFactor := 19 base := int(math.Pow(3, float64(maxFactor))) % 1000000007 sum := 1 for factor \u003e maxFactor { \\\\若指数超出了范围 sum = (sum * base) % 1000000007 factor -= maxFactor } sum = (sum * int(math.Pow(3, float64(factor)))) % 1000000007 remain := n % 3 if remain == 0 { return (sum * 3) % 1000000007 } if remain == 1 { return (sum * 4) % 1000000007 } return (sum * 6) % 1000000007 } 执行用时: 0 ms 内存消耗: 1.9 MB ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/:2:2","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 14","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"DP解法 对于剪绳子I也可以通过动态规划的方法求解。 对于每一次切割，都考虑是直接切割相乘还是将前面的部分再次切割之后相乘。 状态转移方程为：dp[i]=max(dp[i], max(j*dp[i-j], j*(i-j))) 初始状态为dp[2]=1 (由于m\u003e1，必须至少一次切割) func cuttingRope(n int) int { dp := make([]int, n+1) dp[2] = 1 for i := 3; i \u003c n+1; i++ { for j := 2; j \u003c i; j++ { dp[i] = int(math.Max(float64(dp[i]),math.Max(float64(j * dp[i-j]),float64(j*(i-j))))) } } return dp[n] } 执行用时: 0 ms 内存消耗: 1.9 MB 但是对于剪绳子II，有超过范围的数字的情况，使用DP无法得到正确的中间结果，也就无法得到正确的最终结果。 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/:2:3","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 14","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"机器人的运动范围","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 13","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80/"},{"categories":["刷题笔记"],"content":"题目：机器人的运动范围 题目链接。 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入： m = 2, n = 3, k = 1 输出： 3 示例2： 输入: m = 3, n = 1, k = 0 输出: 1 限制： 1 \u003c= m,n \u003c= 100 0 \u003c= k \u003c= 20 ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 13","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80/"},{"categories":["刷题笔记"],"content":"题解 本题依然是经典的DFS，只需使用一个数组存放各个坐标的状态，然后在访问之前判断该坐标的周围的点是否可以被访问即可。 func movingCount(m int, n int, k int) int { block := make([][]bool, m) for i := range block { block[i] = make([]bool, n) } return dfs(0, 0, m, n, k, block) } func dfs(x, y, m, n, k int, block [][]bool) int { if !numberCount(x, y, k) || x \u003e= m || y \u003e= n || block[x][y]{ return 0 } block[x][y] = true sum := 1 sum += dfs(x+1, y, m, n, k, block) sum += dfs(x-1, y, m, n, k, block) sum += dfs(x, y+1, m, n, k, block) sum += dfs(x, y-1, m, n, k, block) return sum } func numberCount(x int, y int, k int) bool { if x \u003c 0 || y \u003c 0 { return false } sum := 0 for ; x \u003e 0; x /= 10 { sum += x %10 } for ; y \u003e 0; y /= 10 { sum += y %10 } if sum \u003c= k { return true } return false } 执行用时: 0 ms 内存消耗: 2.6 MB 不过考虑到这是一个方块内四个方向上的移动，且起点处固定且绝对可达，可以将运动方向固定为向右和向上简化运算，代码如下： func movingCount(m int, n int, k int) int { block := make([][]bool, m+1) for i := range block { block[i] = make([]bool, n+1) } // 起点处绝对可达 block[0][0] = true count := 1 for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { // 判断左边和下方是否可达 if ((i-1 \u003e= 0 \u0026\u0026 block[i-1][j]) || (j-1 \u003e= 0 \u0026\u0026 block[i][j-1])) \u0026\u0026 numberCount(i, j, k) { count++ block[i][j] = true } } } return count } func numberCount(x int, y int, k int) bool { if x \u003c 0 || y \u003c 0 { return false } sum := 0 for ; x \u003e 0; x /= 10 { sum += x %10 } for ; y \u003e 0; y /= 10 { sum += y %10 } if sum \u003c= k { return true } return false } 执行用时: 0 ms 内存消耗: 2 MB ","date":"2021-01-22","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 13","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81%E4%B8%80/"},{"categories":["Go教程"],"content":"Go语言中有着两个很容易混淆的概念: 数组Array和切片Slice。本篇文章将就这两个数据结构的相似与区别进行分析。","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"Go语言中有着两个很容易混淆的概念: 数组Array和切片Slice。本篇文章将就这两个数据结构的相似与区别进行分析。 ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"Array Go语言中的Array即为数据的一种集合，需要在声明时指定容量和初值，且一旦声明就长度固定了，访问时按照索引进行访问。通过内置函数len可以获取数组中的元素个数。 ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:1:0","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"初始化 数组在初始化时必须指定大小和初值，不过Go语言为我们提供了一些更为灵活的方式进行初始化。例如：使用...来自动获取长度；未指定值时，用0赋予初值；指定指定元素的初值等。下面给出一些数组初始化的方式示例。 var arr [5]int //声明了一个大小为5的数组，默认初始化值为[0,0,0,0,0] arr := [5]int{1} //声明并初始化了一个大小为5的数组的第一个元素，初始化后值为[1,0,0,0,0] arr := [...]int{1,2,3} //通过...自动获取数组长度，根据初始化的值的数量将大小初始化为3，初始化后值为[1,2,3] arr := [...]int{4:1} //指定序号为4的元素的值为1，通过...自动获取长度为5，初始化后值为[0,0,0,0,1] ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:1:1","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"函数参数 Go语言数组作为函数参数时，必须指定参数数组的大小，且传入的数组大小必须与指定的大小一致，数组为按值传递的，函数内对数组的值的改变不影响初始数组: package main import \"fmt\" //PrintArray print the value of array func PrintArray(arr [5]int) { arr[0] = 5 fmt.Println(arr) } func main() { a := [...]int{4:1} PrintArray(a) // [5,0,0,0,1] fmt.Println(a) // [0,0,0,0,1] } ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:1:2","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"Slice 切片是Go语言中极为重要的一种数据类型，可以理解为动态长度的数组（虽然实际上Slice结构内包含了一个数组），访问时可以按照数组的方式访问，也可以通过切片操作访问。Slice有三个属性：指针、长度和容量。指针即Slice名，指向的为数组中第一个可以由Slice访问的元素；长度指当前slice中的元素个数，不能超过slice的容量；容量为slice能包含的最大元素数量，但实际上当容量不足时，会自动扩充为原来的两倍。通过内置函数len和cap可以获取slice的长度和容量。 ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:2:0","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"初始化 Slice在初始化时需要初始化指针，长度和容量，容量未指定时将自动初始化为长度的大小。可以通过直接获取数组的引用、获取数组/slice的切片构建或是make函数初始化数组。下面给出一些slice初始化的方式示例。 s := []int{1,2,3} //通过数组的引用初始化，值为[1,2,3],长度和容量为3 arr := [5]int{1,2,3,4,5} s := arr[0:3] //通过数组的切片初始化，值为[1,2,3]，长度为3，容量为5 s := make([]int, 3) //通过make函数初始化，值为[0,0,0]，长度和容量为3 s := make([]int, 3, 5) //通过make函数初始化，值为[0,0,0]，长度为3，容量为5 其中特别需要注意的是通过切片方式初始化。若是通过对slice的切片进行初始化，实际上初始化之后的结构如下图所示： 此时x的值为[2,3,5,7,11]，y的值为[3,5,7]，且两个slice的指针指向的是同一个数组，也即x中的元素的值的改变将会导致y中的值也一起改变。 这样的初始化方式可能会导致内存被过度占用，如只需要使用一个极大的数组中的几个元素，但是由于需要指向整个数组，所以整个数组在GC时都无法被释放，一直占用内存空间。故使用切片操作进行初始化时，最好使用append函数将切片出来的数据复制到一个新的slice中，从而避免内存占用陷阱。 ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:2:1","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"函数参数 Go语言Slice作为函数参数传递时为按引用传递的，函数内对slice内元素的修改将导致函数外的值也发生改变，不过由于传入函数的是一个指针的副本，所以对该指针的修改不会导致原来的指针的变化（例如append函数不会改变原来的slice的值）。具体可以根据下面的代码进行理解： package main import \"fmt\" //PrintSlice print the value of slice func PrintSlice(s []int) { s = append(s, 4) s[0] = -1 fmt.Println(s) } func main() { s := []int{1,2,3,4,5} s1 := s[0:3] fmt.Println(\"s:\",s) //s: [1,2,3,4,5] fmt.Println(\"s1:\",s1) //s1: [1,2,3] PrintSlice(s1) //[-1,2,3,4] fmt.Println(\"s:\",s) //[-1,2,3,4,5] fmt.Println(\"s1:\",s1) //[-1,2,3] } ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:2:2","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"总结 数组长度不能改变，初始化后长度就是固定的；切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 结构不同，数组是一串固定数据，切片描述的是截取数组的一部分数据，从概念上说是一个结构体。 初始化方式不同，如上。另外在声明时的时候：声明数组时，方括号内写明了数组的长度或使用...自动计算长度，而声明slice时，方括号内没有任何字符。 unsafe.sizeof的取值不同，unsafe.sizeof(slice)返回的大小是切片的描述符，不管slice里的元素有多少，返回的数据都是24字节。unsafe.sizeof(arr)的值是在随着arr的元素的个数的增加而增加，是数组所存储的数据内存的大小。 函数调用时的传递方式不同，数组按值传递，slice按引用传递。 ","date":"2021-01-17","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/:3:0","tags":["Go","学习"],"title":"Go语言Array和Slice的区别","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Go教程"],"content":"Go语言中有两种可以储存一串字符的类型，分别是字符串string和byte类型数组[]byte，本文就他们的转换方式进行了说明.","date":"2021-01-16","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/","tags":["Go","学习"],"title":"Go语言string和[]byte互相转换","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["Go教程"],"content":"Go语言中有两种可以储存一串字符的类型，分别是字符串string和byte类型数组[]byte，但是他们直接并不能直接使用等于号赋值，也不能单纯的转换，而是要通过切片来进行转换。 ","date":"2021-01-16","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:0:0","tags":["Go","学习"],"title":"Go语言string和[]byte互相转换","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["Go教程"],"content":"string转换成[]byte 可以直接使用[]byte(str)强制转换。 package main import \"fmt\" func main() { var str string = \"test\" var data []byte = []byte(str) fmt.Println(\"string: \", str) // string: test fmt.Println(\"[]byte: \", data) // []byte: [116 101 115 116] } 可以看到[]byte输出的结果正是string的各个字符对应的ASCII码。 ","date":"2021-01-16","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:1:0","tags":["Go","学习"],"title":"Go语言string和[]byte互相转换","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["Go教程"],"content":"[]byte转换成string 要将byte数组转换成string不能直接转换，而需要将[]byte的切片转换。即使用string(数组名[:])进行转换。 package main import \"fmt\" func main() { var data [5]byte data[0] = 'T' data[1] = 'E' data[2] = 'S' data[3] = 'T' var str string = string(data[:]) fmt.Println(\"[]byte: \", data) // []byte: [84 69 83 84 0] fmt.Println(\"string: \", str) // string: TEST } ","date":"2021-01-16","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:2:0","tags":["Go","学习"],"title":"Go语言string和[]byte互相转换","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["Go教程"],"content":"实践环节 将[][]byte类型的二维数组board初始化为[[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]] board := [][]byte{[]byte(\"ABCE\"),[]byte(\"SFCS\"),[]byte(\"ADEE\")} 由于Go语言需要所有变量（包括中间结果）都有确定的值，所以在声明过程中，需要先将(board[0])[]，(board[1])[]，(board[2])[]都赋予确定的值才能生成board，所以需要在定义内部就进行转换。 ","date":"2021-01-16","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/:3:0","tags":["Go","学习"],"title":"Go语言string和[]byte互相转换","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"},{"categories":["刷题笔记"],"content":"矩阵中的路径","date":"2021-01-16","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 12","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81/"},{"categories":["刷题笔记"],"content":"题目：矩阵中的路径 题目链接。 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,\"b\",“c”,“e”], [“s”,\"f\",\"c\",“s”], [“a”,“d”,\"e\",“e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例 1： 输入： board = [[“A”,“B”,“C”,“E”],[“S”,“F”,“C”,“S”],[“A”,“D”,“E”,“E”]], word = “ABCCED” 输出： true 示例2： 输入: board = [[“a”,“b”],[“c”,“d”]], word = “abcd” 输出: false 限制： 1 \u003c= board.length \u003c= 200 1 \u003c= board[i].length \u003c= 200 ","date":"2021-01-16","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 12","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81/"},{"categories":["刷题笔记"],"content":"题解 本题为经典的DFS，只需注意要将已经选过的字符设置为空字符即可。具体的算法过程见代码注释： func exist(board [][]byte, word string) bool { col := len(board[0]) line := len(board) for i := 0; i \u003c line; i++ { for j := 0; j \u003c col; j++ { //找到第一个值，然后DFS递归查找整条路径 if dfs(board, word , i, j, 0) { return true } } } return false } func dfs(board [][]byte, word string, i int, j int, k int) bool { //找到最后一个数，返回true if k == len(word) { return true } //i, j超范围 if i \u003c 0 || j \u003c 0 || i \u003e= len(board) || j \u003e= len(board[0]) { return false } //进入DFS深度优先搜索 //先把正在遍历的该值重新赋值，如果在该值的周围都搜索不到目标字符，则再把该值还原 //如果在数组中找到第一个字符，则进入下一个字符的查找 if board[i][j] == word[k] { temp := board[i][j] board[i][j] = ' ' //递归在周围寻找 if dfs(board, word, i+1, j, k+1) || dfs(board, word, i, j+1, k+1) || dfs(board, word, i-1, j, k+1) || dfs(board, word, i, j-1, k+1) { return true }else { //没有找到目标字符，还原之前重新赋值的board[i][j] board[i][j] = temp } } return false } 执行用时: 4 ms 内存消耗: 3.2 MB ","date":"2021-01-16","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 12","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%8D%81/"},{"categories":["刷题笔记"],"content":"旋转数组的最小数字","date":"2021-01-16","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%9D/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 11","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%9D/"},{"categories":["刷题笔记"],"content":"题目：旋转数组的最小数字 题目链接。 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入： [3, 4, 5 , 1, 2] 输出： 1 示例2： 输入: [2, 2, 2, 0 , 1] 输出: 0 ","date":"2021-01-16","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%9D/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 11","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%9D/"},{"categories":["刷题笔记"],"content":"题解 本题最容易想到的解法为直接遍历整个数组，找到第一个小于前一个元素的值的元素，若都相等则返回第一个元素即可，代码如下： func minArray(numbers []int) int { if len(numbers) == 0 { return -1 } for seq:= 1; seq \u003c len(numbers); seq++ { if numbers[seq] \u003c numbers[seq-1]{ return numbers[seq] } } return numbers[0] } 执行用时: 4 ms 内存消耗: 3.1 MB 十分简单且结果也不错。但其实这种方法并未用到旋转数组的性质，只是单纯的当作一个部分有序数组来解决问题。时间复杂度为O(n)但实际上，旋转递增数组的定义决定了其最小值的左侧的值一定大于右侧的值，故可以使用二分法解决，时间复杂度为O(log n)。代码如下： func minArray(numbers []int) int { low := 0 high := len(numbers) - 1 for low \u003c high { pivot := low + (high - low) / 2 if numbers[pivot] \u003c numbers[high] { high = pivot } else if numbers[pivot] \u003e numbers[high] { low = pivot + 1 } else { high-- } } return numbers[low] } 执行用时: 4 ms 内存消耗: 3.1 MB ","date":"2021-01-16","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%9D/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 11","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B9%9D/"},{"categories":["刷题笔记"],"content":"青蛙跳台阶问题","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AB/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-II","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AB/"},{"categories":["刷题笔记"],"content":"题目：青蛙跳台阶问题 题目链接。 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入： n = 2 输出： 2 示例2： 输入: n = 7 输出: 21 示例3： 输入: n = 0 输出: 1 限制： 0 \u003c= n \u003c= 100 ","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AB/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-II","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AB/"},{"categories":["刷题笔记"],"content":"题解 本题是Fibonacci数列的变种题，只需理解，对于第n级台阶，可以一次跳上1级到，也可以一次跳上2级到，所以递推公式为f(n) = f(n-1) + f(n-2)，且由于n = 0时输出为1，所以f(0) = f(1) = 1。下面给出代码： func numWays(n int) int { a,b:=1,1 for i:=1;i\u003c=n;i++{ a,b=b,(a+b)%(1e9+7) } return a } 执行用时: 0 ms 内存消耗: 1.9 MB ","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AB/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-II","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AB/"},{"categories":["刷题笔记"],"content":"用两个栈实现队列","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指offer 09","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/"},{"categories":["刷题笔记"],"content":"题目：用两个栈实现队列 题目链接。 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例1 输入： [“CQueue”,“appendTail”,“deleteHead”,“deleteHead”] [[],[3],[],[]] 输出： [null,null,3,-1] 示例2 输入： [“CQueue”,“deleteHead”,“appendTail”,“appendTail”,“deleteHead”,“deleteHead”] [[],[],[5],[2],[],[]] 输出： [null,-1,null,null,5,2] 限制: 1 \u003c= values \u003c= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 ","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指offer 09","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/"},{"categories":["刷题笔记"],"content":"题解 本题比较经典，使用两个栈实现队列。 维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。 根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。过程如图所示： Go语言没有单独的栈的数据结构，所以可以选择数组或是链表的形式进行存储。 ","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指offer 09","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/"},{"categories":["刷题笔记"],"content":"数组形式 使用两个栈stack1, stack2。添加元素时，将元素加入stack1栈顶。取元素时，首先判断stack2是否为空，若为空则将 stack1 里的所有元素弹出插入到 stack2 里，如果 stack2 仍为空，则返回 -1，否则从 stack2 弹出一个元素并返回。 type CQueue struct { stack1, stack2 []int } func Constructor() CQueue { return CQueue{} } func (this *CQueue) AppendTail(value int) { this.stack1 = append(this.stack1, value) } func (this *CQueue) DeleteHead() int { if len(this.stack2) == 0 { if len(this.stack1) == 0 { return -1 } index := len(this.stack1) - 1 for ;index \u003e= 0;index-- { this.stack2 = append(this.stack2, this.stack1[index]) this.stack1 = this.stack1[:index] } } index := len(this.stack2) - 1 value := this.stack2[index] this.stack2 = this.stack2[:index] return value } /** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.DeleteHead(); */ 执行用时: 236 ms 内存消耗: 8.3 MB ","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/:2:1","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指offer 09","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/"},{"categories":["刷题笔记"],"content":"链表 简单的建立链表，记录头尾节点。 type node struct { val int next *node } type CQueue struct { head *node tail *node } func Constructor() CQueue { return CQueue{} } func (this *CQueue) AppendTail(value int) { if this.head == nil { this.head = \u0026node{val:value} this.tail = this.head } else { this.tail.next = \u0026node{val:value} this.tail = this.tail.next } } func (this *CQueue) DeleteHead() int { val := -1 if this.head != nil { val = this.head.val this.head = this.head.next } if this.head == nil { this.tail = nil } return val } /** * Your CQueue object will be instantiated and called as such: * obj := Constructor(); * obj.AppendTail(value); * param_2 := obj.DeleteHead(); */ 执行用时: 232 ms 内存消耗: 8.2 MB ","date":"2021-01-06","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/:2:2","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指offer 09","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%83/"},{"categories":["刷题笔记"],"content":"重建二叉树","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 07","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/"},{"categories":["刷题笔记"],"content":"题目：重建二叉树 题目链接。 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例 输入： 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 输出： 3 / \\ 9 20 / \\ 15 7 限制: 0 \u003c= 节点个数 \u003c= 5000 ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 07","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/"},{"categories":["刷题笔记"],"content":"题解 本题难度不高，主要是对于二叉树的遍历方式的掌握。 前序遍历是先遍历根节点，然后遍历左子树，最后遍历右子树。 中序遍历是先遍历左子树，然后遍历根节点，最后遍历右子树。 后续遍历是先遍历左子树，然后遍历右子树，最后遍历根节点。 所以，可以通过前序遍历，找到二叉树的根节点，再通过找到的根节点，在中序遍历序列中，将树在根节点的前后划分为左子树和右子树，最后对子树进行递归或是迭代，直到将所有节点都插入树内。 以给出的示例为例，首先通过前序遍历序列的第一个值preorder[0] = 3知道根节点为3，然后在中序遍历序列中找到值为3的节点inorder[1]，这样就知道了左子树的节点为[9]，右子树的节点为[15,20,7]。因为preorder[0]为根节点，且由中序遍历可知，左子树加上根节点的节点数序号为index = 1（从0开始计数），所以左子树的节点为preorder[1: index+1]或是inorder[:index]，右子树的节点为preorder[index+1: ]或是inorder[index+1:]。 下面给出递归和迭代两种方法的代码。 ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 07","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/"},{"categories":["刷题笔记"],"content":"递归法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } root := \u0026TreeNode{Val:preorder[0]} // 建树 var index int for i := range inorder{ if inorder[i]==preorder[0]{ // 找到根节点 index = i break } } root.Left = buildTree(preorder[1:index+1],inorder[:index]) // 左子树递归 root.Right = buildTree(preorder[index+1:],inorder[index+1:]) // 右子树递归 return root } 递归法使用的是DFS，用示例的输入演示整个递归的过程如下图所示，数字代表插入子树的顺序： ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/:2:1","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 07","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/"},{"categories":["刷题笔记"],"content":"迭代法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } var stack []*TreeNode //储存节点的栈 root := \u0026TreeNode{Val: preorder[0]} cur := root for pre, in := 1, 0; pre \u003c len(preorder); pre++ { if cur.Val != inorder[in] { // 当前节点不是叶子节点 stack = append(stack, cur) // 节点入栈 cur.Left = \u0026TreeNode{Val: preorder[pre]} // 插入左子树 cur = cur.Left // 向下层移动 } else { // 已经碰到了叶子节点 in++ // 将该叶子节点从给出的序列中删除 for len(stack) \u003e 0 \u0026\u0026 stack[len(stack)-1].Val == inorder[in] { // 退回到上一个有叶子节点的根节点 in++ cur = stack[len(stack)-1] stack = stack[:len(stack)-1] } cur.Right = \u0026TreeNode{Val: preorder[pre]} // 插入右子树 cur = cur.Right } } return root } 迭代法出现在字节跳动面试题中。使用的方法是DFS，一路向下将节点插入树内，直到找到叶子节点，然后退回至有右叶子的第一个根节点，再对右子树DFS。用示例的输入演示整个迭代的过程如下图所示，数字代表插入节点的顺序： ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/:2:2","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 07","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%85%AD/"},{"categories":["刷题笔记"],"content":"从尾到头打印链表","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 06","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/"},{"categories":["刷题笔记"],"content":"题目：从尾到头打印链表 题目链接。 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 输入： head = [1, 3, 2] 输出： [2, 3, 1] 限制: 0 \u003c= 链表长度 \u003c= 10000 ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 06","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/"},{"categories":["刷题笔记"],"content":"题解 本题最容易想到的就是使用一个栈，利用栈先进后出的特性将链表内的值都放入，然后再从栈中取出放入数组内，即可实现倒序输出。不过由于Go语言并无现成的栈的数据结构，且要自己实现显得整到题目的代码较为臃肿，故可以使用别的方法。下面给出我的两种思路（其实归根结底还是用的栈） ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 06","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/"},{"categories":["刷题笔记"],"content":"利用defer和匿名函数 虽然Go语言中并无现成的栈的数据结构，但是Go语言的defer的执行顺序为先进后出（关于defer的介绍可以参考博主的这篇博客，关于匿名函数和闭包的介绍可以参考博主的这篇博客），因此我们可以利用这个特性，循环到链表的每一个节点时，都通过defer调用一个匿名函数，匿名函数的功能为将该节点的值加到数组尾部。当函数执行到return语句时，就按照倒序将链表的值放入了数组中。需要注意的一点是，使用这种方式时，函数的返回值必须命名，否则执行完return语句后函数将返回一个空值，而不会把所有defer执行完成后的数组返回。下面给出代码： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) (list []int) { for ; head != nil; head = head.Next { temp := head.Val defer func() { list = append(list, temp) }() } return } 执行用时: 4 ms 内存消耗: 4.1 MB 可以看到这种方法虽然简便，且利用了Go的特性，但是用时和内存消耗都较大，比较不理想。下面给出第二种更好的方法 ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/:2:1","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 06","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/"},{"categories":["刷题笔记"],"content":"两次遍历 先通过一次遍历整个链表，得到整个链表的长度，然后使用make初始化一个与链表长度相等的数组，再通过第二次遍历整个链表，将链表中的元素按从数组尾部到头部的顺序填充入数组内。下面给出代码： /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) []int { var length int temp := head for ;temp != nil; length++ { temp = temp.Next } list := make([]int, length) for ;head != nil; length-- { list[length - 1] = head.Val head = head.Next } return list } 执行用时: 0 ms 内存消耗: 2.8 MB 这种方法的执行用时和内存消耗均击败了100%的用户。 ","date":"2021-01-05","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/:2:2","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 06","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%94/"},{"categories":["刷题笔记"],"content":"把数字翻译成字符串","date":"2021-01-04","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 05","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/"},{"categories":["刷题笔记"],"content":"题目：把数字翻译成字符串 题目链接。 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 示例 输入： s = “We are happy.” 输出： “We%20are%20happy.” 限制: 0 \u003c= s 的长度 \u003c= 10000 ","date":"2021-01-04","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 05","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/"},{"categories":["刷题笔记"],"content":"题解 直接使用strings下的Replaces接口函数即可。 函数声明为: func Replace(s, old, new string, n int) string 功能为: 返回将s中前n个不重叠old子串都替换为new的新字符串，如果n\u003c0会替换所有old子串。 代码： func replaceSpace(s string) string { return strings.Replace(s, \" \", \"%20\", -1) } 执行用时: 0 ms 内存消耗: 1.9 MB ","date":"2021-01-04","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 05","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E5%9B%9B/"},{"categories":["刷题笔记"],"content":"二维数组中的查找","date":"2021-01-04","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 04","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/"},{"categories":["刷题笔记"],"content":"题目：二维数组中的查找 题目链接。 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 \u003c= n \u003c= 1000 0 \u003c= m \u003c= 1000 ","date":"2021-01-04","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 04","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/"},{"categories":["刷题笔记"],"content":"题解 这道题最简单的做法就是遍历整个数组，每一个元素都拿来比较，找到了就返回true，遍历完之后还没找到就返回false，但这种方法的时间复杂度为O(NM)，且并未利用数组内元素递增的特点。 对于这道题我们先将数组画出来，可以发现对于任意一个元素，总是要大于它的左下方的元素。 所以，我们可以先在第一行进行搜索，找到第一个大于目标值的数，然后一直朝着左下方搜索，该处的值大于目标值就朝左，小于目标值就朝右。整个搜索过程中，找到对应值就返回true，超出边界就立即停止搜索，并返回false。在上图中搜索14的过程如下图所示： 程序代码如下： func findNumberIn2DArray(matrix [][]int, target int) bool { i := 0 if (len(matrix) == 0 || len(matrix[0]) == 0) { // 为空数组直接返回false return false } for ; ((i \u003c len(matrix[0]) - 1) \u0026\u0026 matrix[0][i] \u003c target); i++ { // 在第一行大于target的或是超出边界 } for j := 0; ; { if i \u003c 0 || j \u003e (len(matrix)-1) { return false } if matrix[j][i] == target { return true } else if matrix[j][i] \u003e target { // 朝左 i-- } else { // 朝下 j++ } } } 执行用时: 24 ms 内存消耗: 6.6 MB ","date":"2021-01-04","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 04","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%89/"},{"categories":["Go教程"],"content":"闭包是Go语言中一个非常抽象的概念，也是笔者在Go语言的学习过程中遇到的第一个难点，希望本文可以较为细致的将闭包的概念及特性介绍清楚。","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"闭包是Go语言中一个非常抽象的概念，也是笔者在Go语言的学习过程中遇到的第一个难点，希望本文可以较为细致的将闭包的概念及特性介绍清楚。 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:0:0","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"从函数变量说起 在Go语言中，函数也是一个变量，有类型、有值、有地址、可以被赋值、引用等，函数的零值为nil，但函数之间不能进行比较运算。 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:1:0","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"什么是闭包 由于函数也是变量，自然的可以想到函数也是有地址的（对汇编和操作系统有一定了解后就会知道，每一次函数的调用都会在内存中为该函数分配一片区域，叫做栈帧），而闭包，就可以理解为将函数的地址赋值给了一个变量，又由于Go的变量会进行自动反向引用，所以可以将该变量也当作一个函数使用（且由于栈帧的概念，该变量中还保存着函数被赋值时的内部各个变量的状态）。下面给出例子对其进行展示： package main import \"fmt\" func inc() func() int { //返回值为函数闭包 var x int return func() int { x++ return x } } func main(){ i := incr() //i被赋值为函数闭包，i内保存了x的状态 fmt.printLn(i()) // 1 fmt.printLn(i()) // 2 fmt.printLn(i()) // 3 fmt.printLn(incr()()) //1 fmt.printLn(incr()()) //1 fmt.printLn(incr()()) //1 return } 最开始的三个输出中，由于i内保存了x的状态，故每次对i的调用都会通过i内保存的指向x的指针修改x的值，且状态继续保存在i中，这种状态叫做x的逃逸，它的生命周期没有随着作用域的结束而结束。 之后的三个输出时，由于每一次都调用一次incr()返回的一个闭包，故三次的x属于不同的栈帧，状态各自独立。 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:2:0","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"闭包引用 理解了闭包的定义之后，对于闭包的引用也就自然而然了。闭包的引用其实就和其他变量的引用一样，只不过引用闭包之后得到的是一个保存了闭包声明时的状态的函数。需要注意的是，闭包对于外层词法域变量是引用的，也即，在闭包外部的变量修改可能会影响闭包内部的值，通过以下例子进行说明： x := 1 f := func() { println(x) }() //等价于定义之后调用一次f(), 输出1 x = 2 f() // 2 x = 3 f() // 3 每次调用f时都会对x解引用取值，因为闭包内保存的是x的地址。 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:3:0","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"进阶实例 接下来给出一个较为复杂的例子，涉及到了闭包的循环引用，借此可以加深对闭包的特性的理解： var funcSlice []func() for i := 0; i \u003c 3; i++ { funcSlice = append(funcSlice, func() { println(i) }) } for j := 0; j \u003c 3; j++ { funcSlice[j]() } 读者可以先思考一下这段代码最后会输出什么。 5 4 3 2 1 0 这段代码最后的输出结果为3 3 3。 感觉有点不理解了？这是正常的，让我们分析一下这段代码。 首先是对funcSlice这个slice变量的声明，通过一个for循环，每次都在其末尾添加一个闭包，闭包内是将变量i输出。 看到这个闭包的定义，是不是与之前那个输出x的函数一样？所以这里的i也是一个引用，闭包内实际上保存着的是i的地址，只不过在调用闭包函数时，自动解引用取了其保存的值，可以这样修改这段代码： var funcSlice []func() for i := 0; i \u003c 3; i++ { funcSlice = append(funcSlice, func() { println(\u0026i) }) } for j := 0; j \u003c 3; j++ { funcSlice[j]() } 看到的输出结果为0xc0000ac1d0 0xc0000ac1d0 0xc0000ac1d0，即每一次声明这个闭包得到的i的地址是一样的，故最后i的输出结果都是第一个for循环结束后i被赋予的值3。 那么如果要让输出结果为1 2 3有什么方法呢？下面给出两种解决方案，这两种解决方案也是遇到大多数闭包引用问题时可以使用的方法。 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:4:0","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"一、声明新变量 在返回的闭包内声明新变量：Output := i，并输出j，这样输出的就不再是对i的引用而是Output的值。修改后的代码为： var funcSlice []func() for i := 0; i \u003c 3; i++ { funcSlice = append(funcSlice, func() { Output := i println(Output) }) } for j := 0; j \u003c 3; j++ { funcSlice[j]() } ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:4:1","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"二、声明新函数并传参 将代码修改为: var funcSlice []func() for i := 0; i \u003c 3; i++ { func(i int) { funcSlice = append(funcSlice, func() { println(i) }) //闭包 }(i) //闭包并调用 } for j := 0; j \u003c 3; j++ { funcSlice[j]() //调用 } 现在 println(i) 使用的 i 是通过函数参数传递进来的，并且 Go 语言的函数参数是按值传递的。 所以相当于在这个新的匿名函数内声明了三个变量，被三个闭包函数独立引用。原理跟第一种方法是一样的。 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:4:2","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"思考题 希望通过本篇博客读者能对Go语言中的闭包有一定的掌握。 可以自行尝试使用闭包是实现一个Fibonacci函数，其返回值为一个闭包，能返回连续的Fibonacci数。 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:5:0","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["Go教程"],"content":"参考链接 Go语言闭包详解 ","date":"2021-01-04","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/:6:0","tags":["Go","学习"],"title":"Go语言闭包研究","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/"},{"categories":["刷题笔记"],"content":"斐波那契数列","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-I","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"题目：斐波那契数列 题目链接。 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入： n = 2 输出： 1 示例2： 输入: n = 5 输出: 5 限制： 0 \u003c= n \u003c= 100 ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-I","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"题解 本题也是很经典的基础题，可以使用递归与非递归的解法。也可以选择保存Fibonacci数列的所有值或是只保存所求值。下面给出代码： ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-I","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"递归解法 var fibs [101]int //保存Fibonacci数列中的各个元素值 func fib(n int) int { if fibs[n] != 0{ return fibs[n] % (1e9+7) } if n \u003c= 1{ //F(0) = 0, F(1) = 1 fibs[n] = n }else{ //递归 fibs[n] = fib(n-1) + fib(n-2) } return fibs[n] % (1e9+7) } 执行用时: 0 ms 内存消耗: 1.9 MB (1928 KB) ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/:2:1","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-I","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"非递归解法 func fib(n int) int { f0, f1 := 0, 1 for i := 0; i \u003c n; i++ { f0,f1 = f1,(f0 + f1) % (1e9 + 7); } return f0 } 执行用时: 0 ms 内存消耗: 1.9 MB (1924 KB) 第二种解法执行用时及内存消耗均超过100%的用户。 ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/:2:2","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 10-I","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"categories":["刷题笔记"],"content":"数组中重复的数字","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 03","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["刷题笔记"],"content":"题目：数组中重复的数字 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出： 2 或 3 限制： 2 \u003c= n \u003c= 100000 ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/:1:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 03","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["刷题笔记"],"content":"题解 本题为基础题，难度不高，看到题目即可想到最为简单的暴力哈希解法，不过其实还存在更优解法，下面给予讨论。 ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/:2:0","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 03","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["刷题笔记"],"content":"哈希表 直接使用一个map存放数字是否出现过，遍历整个slice，若数字对应的value为true则返回该数字，否则将其value置为true。 func findRepeatNumber(nums []int) int { stat := make(map[int] bool) for _, val := range nums { if(stat[val]){ return val }else{ stat[val] = true } } return -1 } 执行用时: 48 ms 内存消耗: 8.9 MB ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/:2:1","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 03","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["刷题笔记"],"content":"改进哈希法 由于数组的长度为n，而所有数字都在 0～n-1 的范围内，所以只需要构建一个大小为n的数组temp，nums内的值就是temp的下标，每次遍历到都将其对应的值加一，当该下标对应的值大于1的时候返回该下标。 func findRepeatNumber(nums []int) int { n := len(nums) temp := make([]int, n) for i := 0; i\u003cn;i++{ temp[nums[i]]++ if temp[nums[i]] \u003e 1{ return nums[i] } } return -1 } 执行用时: 36 ms 内存消耗: 8 MB ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/:2:2","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 03","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["刷题笔记"],"content":"排序+遍历 由于只需要找到重复数字，所以可以将nums内的元素排序后对其遍历，将当前数字与下一个数字进行比较，若相等则找到了重复数字，直接返回该值。 func findRepeatNumber(nums []int) int { sort.Ints(nums) for sub, val := range nums{ if(val == nums[sub + 1]){ return val } } return -1 } 执行用时: 56 ms 内存消耗: 8.7 MB ","date":"2021-01-03","objectID":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/:2:3","tags":["Go","LeetCode","算法","剑指Offer"],"title":"LeetCode 剑指Offer 03","uri":"https://lashz.github.io/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"categories":["Go教程"],"content":"本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/","tags":["Go","学习"],"title":"Go语言学习之旅(二)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/"},{"categories":["Go教程"],"content":" Go语言是21世纪的C语言 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。 本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。 转载请注明出处。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/:0:0","tags":["Go","学习"],"title":"Go语言学习之旅(二)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/"},{"categories":["Go教程"],"content":"Go语言语法 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/:1:0","tags":["Go","学习"],"title":"Go语言学习之旅(二)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/"},{"categories":["Go教程"],"content":"函数 函数定义 func g() { } 需要注意的是，左花括号必须与函数名在同一行，否则无法通过编译。 函数参数与返回值 函数可以接收多个参数，并返回多个值，且可以对返回值命名。 func getX2AndX3_2(input int) (x2 int, x3 int) { x2 = 2 * input x3 = 3 * input // return x2, x3 return } 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名，如以下代码片段就会报错，因为error类型的返回值没有命名。 func funcMui(x,y int)(sum int,error){ return x+y,nil } 如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。 如果函数的最后一个参数使用...type的形式，则可以传入变长的参数。如果参数被储存在一个slice类型的变量slice中，则可以通过slice...的形式传递参数，调用变参函数。 package main import \"fmt\" func main() { x := min(1, 3, 2, 0) fmt.Printf(\"The minimum is: %d\\n\", x) slice := []int{7,9,3,5,1} x = min(slice...) fmt.Printf(\"The minimum in the slice is: %d\", x) } func min(s ...int) int { if len(s)==0 { return 0 } min := s[0] for _, v := range s { if v \u003c min { min = v } } return min } /* Output: The minimum is: 0 The minimum in the slice is: 1 */ defer defer是Go中一个特殊的关键字，用于将某函数或是语句的执行顺序推迟到函数返回之前，使得函数在返回时进行一些操作，当有多个defer语句时，其执行顺序为先进后出。通过defer语句可以进行进程中止前的收尾，代码追踪，记录函数参数及返回值等功能，如以下的例子： package main import ( \"io\" \"log\" ) func func1(s string) (n int, err error) { defer func() { log.Printf(\"func1(%q) = %d, %v\", s, n, err) }() return 7, io.EOF } func main() { func1(\"Go\") } /* Output: 2021/1/2 22:46:11 func1(\"Go\") = 7, EOF */ 内置函数 Go 语言拥有一些不需要进行导入操作就可以使用的内置函数，可以理解为某种类型的关键字，但是是以函数的方式实现的。以下给出一个简单的列表，之后会进行深入讨论： 名称 说明 close 用于管道通信 len、cap len 用于返回某个类型的长度或数量（字符串、数组、切片、map 和管道）；cap 是容量的意思，用于返回某个类型的最大容量（只能用于切片和 map） new、make new 和 make 均是用于分配内存：new 用于值类型和用户定义的类型，如自定义结构，make 用于内置引用类型（切片、map 和管道）。它们的用法就像是函数，但是将类型作为参数：new(type)、make(type)。new(T) 分配类型 T 的零值并返回其地址，也就是指向类型 T 的指针。它也可以被用于基本类型：v := new(int)。make(T) 返回类型 T 的初始化之后的值，因此它比 new 进行更多的工作。new() 是一个函数，不要忘记它的括号 copy、append 用于复制和连接切片 panic、recover 两者均用于错误处理机制 print、println 底层打印函数，在部署环境中建议使用 fmt 包 complex、real imag 用于创建和操作复数 未完待续… ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/:1:1","tags":["Go","学习"],"title":"Go语言学习之旅(二)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/"},{"categories":["Go教程"],"content":"本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":" Go语言是21世纪的C语言 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。 本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。 转载请注明出处。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:0:0","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"GO语言的安装 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:1:0","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"Windows下的安装 由于本文作者主要使用的操作系统仍是Windows（没钱买Mac），故首先尝试的是在Windows下安装GO。 进入GO语言官方下载地址，点击Microsoft Windows下方的下载链接自动下载最新的GO语言稳定版安装器。下载完成后运行选择Install即可完成安装。 若安装过Windows下的包管理器如Scoop、Chocolatey等，也可以以使用指令： scoop install go 或是 choco install go 进行安装。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:1:1","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"Linux下的安装 本文作者目前使用的Linux发行版为Debian系下的Ubuntu 20.04和Deepin 20，故使用的指令均为Debian系下的操作。 直接打开终端，输入 sudo apt install golang 即可完成安装。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:1:2","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"GO语言的IDE 一个好的IDE可以使代码的编写事半功倍。本文作者使用的IDE为JetBrains推出的GoLand，平时对于小型代码的编写也会使用Visual Studio Code配上Go语言插件直接进行编写。 两个软件的下载安装配置工作请读者自行学习，本文不再赘述。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:2:0","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"GO语言的语法 Go语言作为21世纪的C语言，许多语法特性与C语言类似，如需要对每个变量的类型都进行声明等，本文不对Go语言的语法基础细节做过多的说明，对于一些基本的语法使用只需参照官方文档或是任意一本参考书即可，本文只对作者学习过程中遇到的较为难以理解或是复杂的概念做一个记录说明。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:3:0","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"变量与常量声明 Go的常量声明使用const关键字：const identifier [type] = value Go的变量声明使用var关键字：var identifier type 可以注意到的是，Go语言的变量声明与其他语言最为不同的一点是，类型放在变量名之后，这点在之后的各个地方都会被使用到，也是新手学习Go语言要跨过的第一个障碍。下面给出几个Go语言声明变量的例子： var a int var b,c *int var d bool // 使用因式分解关键字写法，一般用于全局变量 var ( str string array []int ) 可以看出这样声明可以使得变量的类型定义清晰，每一行声明的变量都一定是同一个类型的。 Go语言的 变量命名需要遵循骆驼命名法，如myArray和startDate。 Go语言的变量在声明的时候会被赋予该类型的初值：int为0，float为0.0，bool为false，string为空字符串，指针为nil。Go中所有的变量都是经过初始化的。Go语言也支持变量在声明的时候进行初始化。同时，若在初始化时不指定类型，Go语言会根据初始化的值自动判断类型，但是没有初始化值且没有类型的变量声明是不被允许的。 由于自动判断特性，Go语言在声明时支持简短声明语法:=，如a := 1，此时a自动被初始化成int型的变量，且值为1。（该种用法只能在一个代码块内对同一个变量名使用一次） Go语言也支持对多个变量同时声明或是同时赋值 a, b, c := 5, 7, \"abc\" //变量之前未被声明 d, e, f = 1, 3, \"def\" //变量之前已被声明 a, b = b, a //交换两个变量的值 _, b = 5, 7 //使用只写变量\"_\"抛弃值 最后，在每个源文件中都支持包含一个init函数，支持对全局变量的初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。如下面的例子中便将Pi初始化为了3.1415 var Pi float64 func init() { Pi = 3.1415 } ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:3:1","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"字符串 与Python字符串类似，支持+拼接字符串，支持len(str)获取字符串长度，也支持str[]获取内容。若是导入了strings包或是strconv包则支持更多的特性。相关的函数接口功能参照该链接，做了较为详细的说明。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:3:2","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"指针 Go语言与C语言类似也有指针，但是Go语言的指针不允许进行指针算法，如pointer+2或是pointer++。 Go的指针会进行自动反向引用，如 v := 1 var p *int p = \u0026v fmt.printLn(\"v: %d p: %d p: %p\\n\",v, p, p) //Output: V: 1 p: 1 p: 0x24f0820 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:3:3","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"if-else结构 标准结构如下 if condition1 { // do something } else if condition2 { // do something else } else { // catch-all or default } ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:3:4","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"switch结构 Go语言中的switch结构接收任意形式的表达式，甚至可以不接收表达式，直接在case中使用语句进行判断（而非C语言一样之能接收整型数据），且不需要使用break语句来结束，当需要继续执行后面的代码时，可以使用fallthrough关键字来达到目的。 switch a, b := x[i], y[j]; { case a \u003c b: t = -1 case a == b: t = 0 case a \u003e b: fallthrough case default: t = 1 } 在上面这个代码片段中，变量 a 和 b 被平行初始化，然后作为判断条件。 ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:3:5","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":["Go教程"],"content":"for结构 基本用法与C语言类似，只是不需要小括号。 for是Go语言提供的唯一一种循环结构，Go语言没有while或是do-while循环，因为都可以以for循环的形式实现。 Go也支持一种特殊的迭代结构for-range，一般形式为：for ix, val := range coll {}。其中val是集合中对应值的拷贝，对其的修改不会改变原集合中的值。 未完待续… ","date":"2020-12-30","objectID":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/:3:6","tags":["Go","学习"],"title":"Go语言学习之旅(一)","uri":"https://lashz.github.io/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/"},{"categories":null,"content":"Lavch 活着… ","date":"2019-08-02","objectID":"https://lashz.github.io/about/:0:0","tags":null,"title":"关于我","uri":"https://lashz.github.io/about/"}]