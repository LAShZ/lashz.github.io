<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刷题笔记 on Lavch&#39;s blog</title>
    <link>https://lashz.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 刷题笔记 on Lavch&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Jan 2021 19:39:31 +0800</lastBuildDate><atom:link href="https://lashz.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 剑指Offer 04</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</link>
      <pubDate>Mon, 04 Jan 2021 19:39:31 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 04 题目：二维数组中的查找 题目链接。
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
 示例
 现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &amp;lt;= n &amp;lt;= 1000
0 &amp;lt;= m &amp;lt;= 1000
题解 这道题最简单的做法就是遍历整个数组，每一个元素都拿来比较，找到了就返回true，遍历完之后还没找到就返回false，但这种方法的时间复杂度为O(NM)，且并未利用数组内元素递增的特点。
对于这道题我们先将数组画出来，可以发现对于任意一个元素，总是要大于它的左下方的元素。
所以，我们可以先在第一行进行搜索，找到第一个大于目标值的数，然后一直朝着左下方搜索，该处的值大于目标值就朝左，小于目标值就朝右。整个搜索过程中，找到对应值就返回true，超出边界就立即停止搜索，并返回false。在上图中搜索14的过程如下图所示：
程序代码如下：
func findNumberIn2DArray(matrix [][]int, target int) bool { i := 0 if (len(matrix) == 0 || len(matrix[0]) == 0) {	// 为空数组直接返回false  return false } for ; ((i &amp;lt; len(matrix[0]) - 1) &amp;amp;&amp;amp; matrix[0][i] &amp;lt; target); i++ {	// 在第一行大于target的或是超出边界 	} for j := 0; ; { if i &amp;lt; 0 || j &amp;gt; (len(matrix)-1) { return false } if matrix[j][i] == target { return true } else if matrix[j][i] &amp;gt; target {	// 朝左  i-- } else {	// 朝下  j++ } } } 执行用时: 24 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 10-I</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</link>
      <pubDate>Sun, 03 Jan 2021 14:23:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 10-I 题目：斐波那契数列 题目链接。
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 示例 1：
 输入：
n = 2
输出：
1
 示例2：
 输入:
n = 5
输出:
5
限制：
0 &amp;lt;= n &amp;lt;= 100
题解 本题也是很经典的基础题，可以使用递归与非递归的解法。也可以选择保存Fibonacci数列的所有值或是只保存所求值。下面给出代码：
递归解法 var fibs [101]int	//保存Fibonacci数列中的各个元素值  func fib(n int) int { if fibs[n] !</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 03</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</link>
      <pubDate>Sun, 03 Jan 2021 11:49:10 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 03 题目：数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
 示例 1：
 输入：
[2, 3, 1, 0, 2, 5, 3]
输出：
2 或 3
限制：
2 &amp;lt;= n &amp;lt;= 100000
题解 本题为基础题，难度不高，看到题目即可想到最为简单的暴力哈希解法，不过其实还存在更优解法，下面给予讨论。
哈希表 直接使用一个map存放数字是否出现过，遍历整个slice，若数字对应的value为true则返回该数字，否则将其value置为true。
func findRepeatNumber(nums []int) int { stat := make(map[int] bool) for _, val := range nums { if(stat[val]){ return val }else{ stat[val] = true } } return -1 } 执行用时: 48 ms
内存消耗: 8.9 MB</description>
    </item>
    
  </channel>
</rss>
