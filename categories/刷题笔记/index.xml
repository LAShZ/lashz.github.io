<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刷题笔记 on Lavch&#39;s blog</title>
    <link>https://lashz.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 刷题笔记 on Lavch&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 16 Jan 2021 16:44:25 +0800</lastBuildDate><atom:link href="https://lashz.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 剑指Offer 12</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-12/</link>
      <pubDate>Sat, 16 Jan 2021 16:44:25 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-12/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 12 题目：矩阵中的路径 题目链接。
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
[[&amp;ldquo;a&amp;rdquo;,&amp;quot;b&amp;quot;,&amp;ldquo;c&amp;rdquo;,&amp;ldquo;e&amp;rdquo;],
[&amp;ldquo;s&amp;rdquo;,&amp;quot;f&amp;quot;,&amp;quot;c&amp;quot;,&amp;ldquo;s&amp;rdquo;],
[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;d&amp;rdquo;,&amp;quot;e&amp;quot;,&amp;ldquo;e&amp;rdquo;]]
但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
 示例 1：
 输入：
board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo;
输出：
true
 示例2：
 输入:
board = [[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;],[&amp;ldquo;c&amp;rdquo;,&amp;ldquo;d&amp;rdquo;]], word = &amp;ldquo;abcd&amp;rdquo;
输出:
false
限制：
1 &amp;lt;= board.length &amp;lt;= 200
1 &amp;lt;= board[i].length &amp;lt;= 200
题解 本题为经典的DFS，只需注意要将已经选过的字符设置为空字符即可。具体的算法过程见代码注释：
func exist(board [][]byte, word string) bool { col := len(board[0]) line := len(board) for i := 0; i &amp;lt; line; i++ { for j := 0; j &amp;lt; col; j++ { //找到第一个值，然后DFS递归查找整条路径  if dfs(board, word , i, j, 0) { return true } } } return false } func dfs(board [][]byte, word string, i int, j int, k int) bool { //找到最后一个数，返回true 	if k == len(word) { return true } //i, j超范围 	if i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt;= len(board) || j &amp;gt;= len(board[0]) { return false } //进入DFS深度优先搜索  //先把正在遍历的该值重新赋值，如果在该值的周围都搜索不到目标字符，则再把该值还原  //如果在数组中找到第一个字符，则进入下一个字符的查找 	if board[i][j] == word[k] { temp := board[i][j] board[i][j] = &amp;#39; &amp;#39; //递归在周围寻找 	if dfs(board, word, i+1, j, k+1) || dfs(board, word, i, j+1, k+1) || dfs(board, word, i-1, j, k+1) || dfs(board, word, i, j-1, k+1) { return true }else { //没有找到目标字符，还原之前重新赋值的board[i][j] 	board[i][j] = temp } } return false } 执行用时: 4 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 11</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-11/</link>
      <pubDate>Sat, 16 Jan 2021 16:44:04 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-11/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 11 题目：旋转数组的最小数字 题目链接。
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。
 示例 1：
 输入：
[3, 4, 5 , 1, 2]
输出：
1
 示例2：
 输入:
[2, 2, 2, 0 , 1]
输出:
0
题解 本题最容易想到的解法为直接遍历整个数组，找到第一个小于前一个元素的值的元素，若都相等则返回第一个元素即可，代码如下：
func minArray(numbers []int) int { if len(numbers) == 0 { return -1 } for seq:= 1; seq &amp;lt; len(numbers); seq++ { if numbers[seq] &amp;lt; numbers[seq-1]{ return numbers[seq] } } return numbers[0] } 执行用时: 4 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 10-II</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-ii/</link>
      <pubDate>Wed, 06 Jan 2021 23:27:26 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-ii/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 10-II 题目：青蛙跳台阶问题 题目链接。
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 示例 1：
 输入：
n = 2
输出：
2
 示例2：
 输入:
n = 7
输出:
21
 示例3：
 输入:
n = 0
输出:
1
限制：
0 &amp;lt;= n &amp;lt;= 100
题解 本题是Fibonacci数列的变种题，只需理解，对于第n级台阶，可以一次跳上1级到，也可以一次跳上2级到，所以递推公式为f(n) = f(n-1) + f(n-2)，且由于n = 0时输出为1，所以f(0) = f(1) = 1。下面给出代码：
func numWays(n int) int { a,b:=1,1 for i:=1;i&amp;lt;=n;i++{ a,b=b,(a+b)%(1e9+7) } return a } 执行用时: 0 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指offer 09</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-09/</link>
      <pubDate>Wed, 06 Jan 2021 15:13:33 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-09/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 09 题目：用两个栈实现队列 题目链接。
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
 示例1
 输入：
[&amp;ldquo;CQueue&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;] [[],[3],[],[]]
输出：
[null,null,3,-1]
 示例2
 输入：
[&amp;ldquo;CQueue&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;] [[],[],[5],[2],[],[]]
输出：
[null,-1,null,null,5,2]
限制:
 1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  题解 本题比较经典，使用两个栈实现队列。
维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。
根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。过程如图所示：
Go语言没有单独的栈的数据结构，所以可以选择数组或是链表的形式进行存储。
数组形式 使用两个栈stack1, stack2。添加元素时，将元素加入stack1栈顶。取元素时，首先判断stack2是否为空，若为空则将 stack1 里的所有元素弹出插入到 stack2 里，如果 stack2 仍为空，则返回 -1，否则从 stack2 弹出一个元素并返回。
type CQueue struct { stack1, stack2 []int } func Constructor() CQueue { return CQueue{} } func (this *CQueue) AppendTail(value int) { this.</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 07</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-07/</link>
      <pubDate>Tue, 05 Jan 2021 19:50:31 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-07/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 07 题目：重建二叉树 题目链接。
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
 示例
 输入：
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
输出：
 3 / \ 9 20 / \ 15 7 限制:
0 &amp;lt;= 节点个数 &amp;lt;= 5000
题解 本题难度不高，主要是对于二叉树的遍历方式的掌握。
前序遍历是先遍历根节点，然后遍历左子树，最后遍历右子树。
中序遍历是先遍历左子树，然后遍历根节点，最后遍历右子树。
后续遍历是先遍历左子树，然后遍历右子树，最后遍历根节点。
所以，可以通过前序遍历，找到二叉树的根节点，再通过找到的根节点，在中序遍历序列中，将树在根节点的前后划分为左子树和右子树，最后对子树进行递归或是迭代，直到将所有节点都插入树内。
以给出的示例为例，首先通过前序遍历序列的第一个值preorder[0] = 3知道根节点为3，然后在中序遍历序列中找到值为3的节点inorder[1]，这样就知道了左子树的节点为[9]，右子树的节点为[15,20,7]。因为preorder[0]为根节点，且由中序遍历可知，左子树加上根节点的节点数序号为index = 1（从0开始计数），所以左子树的节点为preorder[1: index+1]或是inorder[:index]，右子树的节点为preorder[index+1: ]或是inorder[index+1:]。
下面给出递归和迭代两种方法的代码。
递归法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } root := &amp;amp;TreeNode{Val:preorder[0]}	// 建树  var index int for i := range inorder{ if inorder[i]==preorder[0]{	// 找到根节点  index = i break } } root.</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 06</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-06/</link>
      <pubDate>Tue, 05 Jan 2021 11:24:07 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-06/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 06 题目：从尾到头打印链表 题目链接。
输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
 示例
 输入：
head = [1, 3, 2]
输出：
[2, 3, 1]
限制:
0 &amp;lt;= 链表长度 &amp;lt;= 10000
题解 本题最容易想到的就是使用一个栈，利用栈先进后出的特性将链表内的值都放入，然后再从栈中取出放入数组内，即可实现倒序输出。不过由于Go语言并无现成的栈的数据结构，且要自己实现显得整到题目的代码较为臃肿，故可以使用别的方法。下面给出我的两种思路（其实归根结底还是用的栈）
利用defer和匿名函数 虽然Go语言中并无现成的栈的数据结构，但是Go语言的defer的执行顺序为先进后出（关于defer的介绍可以参考博主的这篇博客，关于匿名函数和闭包的介绍可以参考博主的这篇博客），因此我们可以利用这个特性，循环到链表的每一个节点时，都通过defer调用一个匿名函数，匿名函数的功能为将该节点的值加到数组尾部。当函数执行到return语句时，就按照倒序将链表的值放入了数组中。需要注意的一点是，使用这种方式时，函数的返回值必须命名，否则执行完return语句后函数将返回一个空值，而不会把所有defer执行完成后的数组返回。下面给出代码：
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) (list []int) { for ; head != nil; head = head.Next { temp := head.Val defer func() { list = append(list, temp) }() } return } 执行用时: 4 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 05</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-05/</link>
      <pubDate>Mon, 04 Jan 2021 21:54:24 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-05/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 05 题目：把数字翻译成字符串 题目链接。
请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
 示例
 输入：
s = &amp;ldquo;We are happy.&amp;rdquo;
输出：
&amp;ldquo;We%20are%20happy.&amp;rdquo;
限制:
0 &amp;lt;= s 的长度 &amp;lt;= 10000
题解 直接使用strings下的Replaces接口函数即可。
函数声明为: func Replace(s, old, new string, n int) string
功能为: 返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&amp;lt;0会替换所有old子串。
代码：
func replaceSpace(s string) string { return strings.Replace(s, &amp;#34; &amp;#34;, &amp;#34;%20&amp;#34;, -1) } 执行用时: 0 ms
内存消耗: 1.9 MB</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 04</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</link>
      <pubDate>Mon, 04 Jan 2021 19:39:31 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 04 题目：二维数组中的查找 题目链接。
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
 示例
 现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &amp;lt;= n &amp;lt;= 1000
0 &amp;lt;= m &amp;lt;= 1000
题解 这道题最简单的做法就是遍历整个数组，每一个元素都拿来比较，找到了就返回true，遍历完之后还没找到就返回false，但这种方法的时间复杂度为O(NM)，且并未利用数组内元素递增的特点。
对于这道题我们先将数组画出来，可以发现对于任意一个元素，总是要大于它的左下方的元素。
所以，我们可以先在第一行进行搜索，找到第一个大于目标值的数，然后一直朝着左下方搜索，该处的值大于目标值就朝左，小于目标值就朝右。整个搜索过程中，找到对应值就返回true，超出边界就立即停止搜索，并返回false。在上图中搜索14的过程如下图所示：
程序代码如下：
func findNumberIn2DArray(matrix [][]int, target int) bool { i := 0 if (len(matrix) == 0 || len(matrix[0]) == 0) {	// 为空数组直接返回false  return false } for ; ((i &amp;lt; len(matrix[0]) - 1) &amp;amp;&amp;amp; matrix[0][i] &amp;lt; target); i++ {	// 在第一行大于target的或是超出边界 	} for j := 0; ; { if i &amp;lt; 0 || j &amp;gt; (len(matrix)-1) { return false } if matrix[j][i] == target { return true } else if matrix[j][i] &amp;gt; target {	// 朝左  i-- } else {	// 朝下  j++ } } } 执行用时: 24 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 10-I</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</link>
      <pubDate>Sun, 03 Jan 2021 14:23:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 10-I 题目：斐波那契数列 题目链接。
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 示例 1：
 输入：
n = 2
输出：
1
 示例2：
 输入:
n = 5
输出:
5
限制：
0 &amp;lt;= n &amp;lt;= 100
题解 本题也是很经典的基础题，可以使用递归与非递归的解法。也可以选择保存Fibonacci数列的所有值或是只保存所求值。下面给出代码：
递归解法 var fibs [101]int	//保存Fibonacci数列中的各个元素值  func fib(n int) int { if fibs[n] !</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 03</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</link>
      <pubDate>Sun, 03 Jan 2021 11:49:10 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 03 题目：数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
 示例 1：
 输入：
[2, 3, 1, 0, 2, 5, 3]
输出：
2 或 3
限制：
2 &amp;lt;= n &amp;lt;= 100000
题解 本题为基础题，难度不高，看到题目即可想到最为简单的暴力哈希解法，不过其实还存在更优解法，下面给予讨论。
哈希表 直接使用一个map存放数字是否出现过，遍历整个slice，若数字对应的value为true则返回该数字，否则将其value置为true。
func findRepeatNumber(nums []int) int { stat := make(map[int] bool) for _, val := range nums { if(stat[val]){ return val }else{ stat[val] = true } } return -1 } 执行用时: 48 ms
内存消耗: 8.9 MB</description>
    </item>
    
  </channel>
</rss>
