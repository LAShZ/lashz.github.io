<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>刷题笔记 on Lavch&#39;s blog</title>
    <link>https://lashz.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 刷题笔记 on Lavch&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Jan 2021 19:50:31 +0800</lastBuildDate><atom:link href="https://lashz.github.io/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 剑指Offer 07</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-07/</link>
      <pubDate>Tue, 05 Jan 2021 19:50:31 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-07/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 07 题目：重建二叉树 题目链接。
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
 示例
 输入：
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
输出：
 3 / \ 9 20 / \ 15 7 限制:
0 &amp;lt;= 节点个数 &amp;lt;= 5000
题解 本题难度不高，主要是对于二叉树的遍历方式的掌握。
前序遍历是先遍历根节点，然后遍历左子树，最后遍历右子树。
中序遍历是先遍历左子树，然后遍历根节点，最后遍历右子树。
后续遍历是先遍历左子树，然后遍历右子树，最后遍历根节点。
所以，可以通过前序遍历，找到二叉树的根节点，再通过找到的根节点，在中序遍历序列中，将树在根节点的前后划分为左子树和右子树，最后对子树进行递归或是迭代，直到将所有节点都插入树内。
以给出的示例为例，首先通过前序遍历序列的第一个值preorder[0] = 3知道根节点为3，然后在中序遍历序列中找到值为3的节点inorder[1]，这样就知道了左子树的节点为[9]，右子树的节点为[15,20,7]。因为preorder[0]为根节点，且由中序遍历可知，左子树加上根节点的节点数序号为index = 1（从0开始计数），所以左子树的节点为preorder[1: index+1]或是inorder[:index]，右子树的节点为preorder[index+1: ]或是inorder[index+1:]。
下面给出递归和迭代两种方法的代码。
递归法 /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } root := &amp;amp;TreeNode{Val:preorder[0]}	// 建树  var index int for i := range inorder{ if inorder[i]==preorder[0]{	// 找到根节点  index = i break } } root.</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 06</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-06/</link>
      <pubDate>Tue, 05 Jan 2021 11:24:07 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-06/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 06 题目：从尾到头打印链表 题目链接。
输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
 示例
 输入：
head = [1, 3, 2]
输出：
[2, 3, 1]
限制:
0 &amp;lt;= 链表长度 &amp;lt;= 10000
题解 本题最容易想到的就是使用一个栈，利用栈先进后出的特性将链表内的值都放入，然后再从栈中取出放入数组内，即可实现倒序输出。不过由于Go语言并无现成的栈的数据结构，且要自己实现显得整到题目的代码较为臃肿，故可以使用别的方法。下面给出我的两种思路（其实归根结底还是用的栈）
利用defer和匿名函数 虽然Go语言中并无现成的栈的数据结构，但是Go语言的defer的执行顺序为先进后出（关于defer的介绍可以参考博主的这篇博客，关于匿名函数和闭包的介绍可以参考博主的这篇博客），因此我们可以利用这个特性，循环到链表的每一个节点时，都通过defer调用一个匿名函数，匿名函数的功能为将该节点的值加到数组尾部。当函数执行到return语句时，就按照倒序将链表的值放入了数组中。需要注意的一点是，使用这种方式时，函数的返回值必须命名，否则执行完return语句后函数将返回一个空值，而不会把所有defer执行完成后的数组返回。下面给出代码：
/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reversePrint(head *ListNode) (list []int) { for ; head != nil; head = head.Next { temp := head.Val defer func() { list = append(list, temp) }() } return } 执行用时: 4 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 05</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-05/</link>
      <pubDate>Mon, 04 Jan 2021 21:54:24 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-05/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 05 题目：把数字翻译成字符串 题目链接。
请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
 示例
 输入：
s = &amp;ldquo;We are happy.&amp;rdquo;
输出：
&amp;ldquo;We%20are%20happy.&amp;rdquo;
限制:
0 &amp;lt;= s 的长度 &amp;lt;= 10000
题解 直接使用strings下的Replaces接口函数即可。
函数声明为: func Replace(s, old, new string, n int) string
功能为: 返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&amp;lt;0会替换所有old子串。
代码：
func replaceSpace(s string) string { return strings.Replace(s, &amp;#34; &amp;#34;, &amp;#34;%20&amp;#34;, -1) } 执行用时: 0 ms
内存消耗: 1.9 MB</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 04</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</link>
      <pubDate>Mon, 04 Jan 2021 19:39:31 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-04/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 04 题目：二维数组中的查找 题目链接。
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
 示例
 现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
限制：
0 &amp;lt;= n &amp;lt;= 1000
0 &amp;lt;= m &amp;lt;= 1000
题解 这道题最简单的做法就是遍历整个数组，每一个元素都拿来比较，找到了就返回true，遍历完之后还没找到就返回false，但这种方法的时间复杂度为O(NM)，且并未利用数组内元素递增的特点。
对于这道题我们先将数组画出来，可以发现对于任意一个元素，总是要大于它的左下方的元素。
所以，我们可以先在第一行进行搜索，找到第一个大于目标值的数，然后一直朝着左下方搜索，该处的值大于目标值就朝左，小于目标值就朝右。整个搜索过程中，找到对应值就返回true，超出边界就立即停止搜索，并返回false。在上图中搜索14的过程如下图所示：
程序代码如下：
func findNumberIn2DArray(matrix [][]int, target int) bool { i := 0 if (len(matrix) == 0 || len(matrix[0]) == 0) {	// 为空数组直接返回false  return false } for ; ((i &amp;lt; len(matrix[0]) - 1) &amp;amp;&amp;amp; matrix[0][i] &amp;lt; target); i++ {	// 在第一行大于target的或是超出边界 	} for j := 0; ; { if i &amp;lt; 0 || j &amp;gt; (len(matrix)-1) { return false } if matrix[j][i] == target { return true } else if matrix[j][i] &amp;gt; target {	// 朝左  i-- } else {	// 朝下  j++ } } } 执行用时: 24 ms</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 10-I</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</link>
      <pubDate>Sun, 03 Jan 2021 14:23:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-10-i/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 10-I 题目：斐波那契数列 题目链接。
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 示例 1：
 输入：
n = 2
输出：
1
 示例2：
 输入:
n = 5
输出:
5
限制：
0 &amp;lt;= n &amp;lt;= 100
题解 本题也是很经典的基础题，可以使用递归与非递归的解法。也可以选择保存Fibonacci数列的所有值或是只保存所求值。下面给出代码：
递归解法 var fibs [101]int	//保存Fibonacci数列中的各个元素值  func fib(n int) int { if fibs[n] !</description>
    </item>
    
    <item>
      <title>LeetCode 剑指Offer 03</title>
      <link>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</link>
      <pubDate>Sun, 03 Jan 2021 11:49:10 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/leetcode-%E5%89%91%E6%8C%87offer-03/</guid>
      <description>LeetCode刷题笔记&amp;ndash;剑指Offer 03 题目：数组中重复的数字 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
 示例 1：
 输入：
[2, 3, 1, 0, 2, 5, 3]
输出：
2 或 3
限制：
2 &amp;lt;= n &amp;lt;= 100000
题解 本题为基础题，难度不高，看到题目即可想到最为简单的暴力哈希解法，不过其实还存在更优解法，下面给予讨论。
哈希表 直接使用一个map存放数字是否出现过，遍历整个slice，若数字对应的value为true则返回该数字，否则将其value置为true。
func findRepeatNumber(nums []int) int { stat := make(map[int] bool) for _, val := range nums { if(stat[val]){ return val }else{ stat[val] = true } } return -1 } 执行用时: 48 ms
内存消耗: 8.9 MB</description>
    </item>
    
  </channel>
</rss>
