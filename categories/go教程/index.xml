<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go教程 on Lavch&#39;s blog</title>
    <link>https://lashz.github.io/categories/go%E6%95%99%E7%A8%8B/</link>
    <description>Recent content in Go教程 on Lavch&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 17 Jan 2021 12:23:06 +0800</lastBuildDate><atom:link href="https://lashz.github.io/categories/go%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go语言Array和Slice的区别</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 17 Jan 2021 12:23:06 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80array%E5%92%8Cslice%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Go语言Array和Slice的区别 Go语言中有着两个很容易混淆的概念: 数组Array和切片Slice。本篇文章将就这两个数据结构的相似与区别进行分析。
Array Go语言中的Array即为数据的一种集合，需要在声明时指定容量和初值，且一旦声明就长度固定了，访问时按照索引进行访问。通过内置函数len可以获取数组中的元素个数。
初始化 数组在初始化时必须指定大小和初值，不过Go语言为我们提供了一些更为灵活的方式进行初始化。例如：使用...来自动获取长度；未指定值时，用0赋予初值；指定指定元素的初值等。下面给出一些数组初始化的方式示例。
var arr [5]int	//声明了一个大小为5的数组，默认初始化值为[0,0,0,0,0] arr := [5]int{1}	//声明并初始化了一个大小为5的数组的第一个元素，初始化后值为[1,0,0,0,0] arr := [...]int{1,2,3}	//通过...自动获取数组长度，根据初始化的值的数量将大小初始化为3，初始化后值为[1,2,3] arr := [...]int{4:1}	//指定序号为4的元素的值为1，通过...自动获取长度为5，初始化后值为[0,0,0,0,1] 函数参数 Go语言数组作为函数参数时，必须指定参数数组的大小，且传入的数组大小必须与指定的大小一致，数组为按值传递的，函数内对数组的值的改变不影响初始数组:
package main import &amp;#34;fmt&amp;#34; //PrintArray print the value of array func PrintArray(arr [5]int) { arr[0] = 5 fmt.Println(arr) } func main() { a := [...]int{4:1} PrintArray(a)	// [5,0,0,0,1]  fmt.Println(a)	// [0,0,0,0,1] } Slice 切片是Go语言中极为重要的一种数据类型，可以理解为动态长度的数组（虽然实际上Slice结构内包含了一个数组），访问时可以按照数组的方式访问，也可以通过切片操作访问。Slice有三个属性：指针、长度和容量。指针即Slice名，指向的为数组中第一个可以由Slice访问的元素；长度指当前slice中的元素个数，不能超过slice的容量；容量为slice能包含的最大元素数量，但实际上当容量不足时，会自动扩充为原来的两倍。通过内置函数len和cap可以获取slice的长度和容量。
初始化 Slice在初始化时需要初始化指针，长度和容量，容量未指定时将自动初始化为长度的大小。可以通过直接获取数组的引用、获取数组/slice的切片构建或是make函数初始化数组。下面给出一些slice初始化的方式示例。
s := []int{1,2,3}	//通过数组的引用初始化，值为[1,2,3],长度和容量为3  arr := [5]int{1,2,3,4,5} s := arr[0:3]	//通过数组的切片初始化，值为[1,2,3]，长度为3，容量为5  s := make([]int, 3)	//通过make函数初始化，值为[0,0,0]，长度和容量为3  s := make([]int, 3, 5)	//通过make函数初始化，值为[0,0,0]，长度为3，容量为5 其中特别需要注意的是通过切片方式初始化。若是通过对slice的切片进行初始化，实际上初始化之后的结构如下图所示：</description>
    </item>
    
    <item>
      <title>Go语言string和[]byte互相转换</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sat, 16 Jan 2021 18:13:50 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80string%E5%92%8Cbyte%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</guid>
      <description>Go语言string和[]byte互相转换 Go语言中有两种可以储存一串字符的类型，分别是字符串string和byte类型数组[]byte，但是他们直接并不能直接使用等于号赋值，也不能单纯的转换，而是要通过切片来进行转换。
string转换成[]byte 可以直接使用[]byte(str)强制转换。
package main import &amp;#34;fmt&amp;#34; func main() { var str string = &amp;#34;test&amp;#34; var data []byte = []byte(str) fmt.Println(&amp;#34;string: &amp;#34;, str)	// string: test  fmt.Println(&amp;#34;[]byte: &amp;#34;, data)	// []byte: [116 101 115 116] } 可以看到[]byte输出的结果正是string的各个字符对应的ASCII码。
[]byte转换成string 要将byte数组转换成string不能直接转换，而需要将[]byte的切片转换。即使用string(数组名[:])进行转换。
package main import &amp;#34;fmt&amp;#34; func main() { var data [5]byte data[0] = &amp;#39;T&amp;#39; data[1] = &amp;#39;E&amp;#39; data[2] = &amp;#39;S&amp;#39; data[3] = &amp;#39;T&amp;#39; var str string = string(data[:]) fmt.Println(&amp;#34;[]byte: &amp;#34;, data)	// []byte: [84 69 83 84 0] 	fmt.</description>
    </item>
    
    <item>
      <title>Go语言闭包研究</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Mon, 04 Jan 2021 15:28:37 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E9%97%AD%E5%8C%85%E7%A0%94%E7%A9%B6/</guid>
      <description>Go语言闭包研究 闭包是Go语言中一个非常抽象的概念，也是笔者在Go语言的学习过程中遇到的第一个难点，希望本文可以较为细致的将闭包的概念及特性介绍清楚。
从函数变量说起 在Go语言中，函数也是一个变量，有类型、有值、有地址、可以被赋值、引用等，函数的零值为nil，但函数之间不能进行比较运算。
什么是闭包 由于函数也是变量，自然的可以想到函数也是有地址的（对汇编和操作系统有一定了解后就会知道，每一次函数的调用都会在内存中为该函数分配一片区域，叫做栈帧），而闭包，就可以理解为将函数的地址赋值给了一个变量，又由于Go的变量会进行自动反向引用，所以可以将该变量也当作一个函数使用（且由于栈帧的概念，该变量中还保存着函数被赋值时的内部各个变量的状态）。下面给出例子对其进行展示：
package main import &amp;#34;fmt&amp;#34; func inc() func() int {	//返回值为函数闭包  var x int return func() int { x++ return x } } func main(){ i := incr()	//i被赋值为函数闭包，i内保存了x的状态  fmt.printLn(i())	// 1  fmt.printLn(i())	// 2  fmt.printLn(i())	// 3  fmt.printLn(incr()())	//1  fmt.printLn(incr()())	//1  fmt.printLn(incr()())	//1  return } 最开始的三个输出中，由于i内保存了x的状态，故每次对i的调用都会通过i内保存的指向x的指针修改x的值，且状态继续保存在i中，这种状态叫做x的逃逸，它的生命周期没有随着作用域的结束而结束。
之后的三个输出时，由于每一次都调用一次incr()返回的一个闭包，故三次的x属于不同的栈帧，状态各自独立。
闭包引用 理解了闭包的定义之后，对于闭包的引用也就自然而然了。闭包的引用其实就和其他变量的引用一样，只不过引用闭包之后得到的是一个保存了闭包声明时的状态的函数。需要注意的是，闭包对于外层词法域变量是引用的，也即，在闭包外部的变量修改可能会影响闭包内部的值，通过以下例子进行说明：
x := 1 f := func() { println(x) }()	//等价于定义之后调用一次f(), 输出1 x = 2 f()	// 2 x = 3 f()	// 3 每次调用f时都会对x解引用取值，因为闭包内保存的是x的地址。</description>
    </item>
    
    <item>
      <title>Go语言学习之旅(二)</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/</link>
      <pubDate>Wed, 30 Dec 2020 18:45:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%BA%8C/</guid>
      <description>Go语言学习之旅  Go语言是21世纪的C语言
 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。
本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。
转载请注明出处。
Go语言语法 函数 函数定义 func g() { } 需要注意的是，左花括号必须与函数名在同一行，否则无法通过编译。
函数参数与返回值 函数可以接收多个参数，并返回多个值，且可以对返回值命名。
func getX2AndX3_2(input int) (x2 int, x3 int) { x2 = 2 * input x3 = 3 * input // return x2, x3  return } 在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名，如以下代码片段就会报错，因为error类型的返回值没有命名。
func funcMui(x,y int)(sum int,error){ return x+y,nil } 如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。
如果函数的最后一个参数使用...type的形式，则可以传入变长的参数。如果参数被储存在一个slice类型的变量slice中，则可以通过slice...的形式传递参数，调用变参函数。
package main import &amp;#34;fmt&amp;#34; func main() { x := min(1, 3, 2, 0) fmt.Printf(&amp;#34;The minimum is: %d\n&amp;#34;, x) slice := []int{7,9,3,5,1} x = min(slice.</description>
    </item>
    
    <item>
      <title>Go语言学习之旅(一)</title>
      <link>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/</link>
      <pubDate>Wed, 30 Dec 2020 17:45:11 +0800</pubDate>
      
      <guid>https://lashz.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85%E4%B8%80/</guid>
      <description>Go语言学习之旅  Go语言是21世纪的C语言
 本文是用于记录作者在Go语言的学习过程中经历的种种，方便日后复习，也为他人提供些许的经验参考。
本文开始于作者大三寒假时期，对于数据结构、算法、计算机网络等知识都有一定的了解，也有过一定的项目经验，故一些较为基础的知识不再予以记录，如若读者遇到了难以理解的部分，可以上网自行寻找相关的资料，若仍然无法理解，请联系作者加以解释。也欢迎各位对本文中出现的错误以及不足之处予以指正。
转载请注明出处。
GO语言的安装 Windows下的安装 由于本文作者主要使用的操作系统仍是Windows（没钱买Mac），故首先尝试的是在Windows下安装GO。
进入GO语言官方下载地址，点击Microsoft Windows下方的下载链接自动下载最新的GO语言稳定版安装器。下载完成后运行选择Install即可完成安装。
若安装过Windows下的包管理器如Scoop、Chocolatey等，也可以以使用指令：
scoop install go 或是
choco install go 进行安装。
Linux下的安装 本文作者目前使用的Linux发行版为Debian系下的Ubuntu 20.04和Deepin 20，故使用的指令均为Debian系下的操作。
直接打开终端，输入
sudo apt install golang 即可完成安装。
GO语言的IDE 一个好的IDE可以使代码的编写事半功倍。本文作者使用的IDE为JetBrains推出的GoLand，平时对于小型代码的编写也会使用Visual Studio Code配上Go语言插件直接进行编写。
两个软件的下载安装配置工作请读者自行学习，本文不再赘述。
GO语言的语法 Go语言作为21世纪的C语言，许多语法特性与C语言类似，如需要对每个变量的类型都进行声明等，本文不对Go语言的语法基础细节做过多的说明，对于一些基本的语法使用只需参照官方文档或是任意一本参考书即可，本文只对作者学习过程中遇到的较为难以理解或是复杂的概念做一个记录说明。
变量与常量声明 Go的常量声明使用const关键字：const identifier [type] = value
Go的变量声明使用var关键字：var identifier type
可以注意到的是，Go语言的变量声明与其他语言最为不同的一点是，类型放在变量名之后，这点在之后的各个地方都会被使用到，也是新手学习Go语言要跨过的第一个障碍。下面给出几个Go语言声明变量的例子：
var a int var b,c *int var d bool // 使用因式分解关键字写法，一般用于全局变量 var ( str string array []int ) 可以看出这样声明可以使得变量的类型定义清晰，每一行声明的变量都一定是同一个类型的。
Go语言的 变量命名需要遵循骆驼命名法，如myArray和startDate。
Go语言的变量在声明的时候会被赋予该类型的初值：int为0，float为0.0，bool为false，string为空字符串，指针为nil。Go中所有的变量都是经过初始化的。Go语言也支持变量在声明的时候进行初始化。同时，若在初始化时不指定类型，Go语言会根据初始化的值自动判断类型，但是没有初始化值且没有类型的变量声明是不被允许的。</description>
    </item>
    
  </channel>
</rss>
